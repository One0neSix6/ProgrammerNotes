---
title: FFmpeg 实现解封装
date: 2025-12-03 10:11:41
categories: 音视频
tags: FFmpeg
---

## 代码示例
```cpp
#include <iostream>
#include <string>

extern "C" {
#include "libavformat/avformat.h"
}

int main() {
    const std::string file_name = "cat.mp4";
    AVFormatContext* fmt_ctx = nullptr;
    // 打开输入文件
    if (avformat_open_input(&fmt_ctx, file_name.c_str(), nullptr, nullptr) < 0) {
        std::cerr << "open input fail" << std::endl;
        return -1;
    }
    // 获取流信息
    if (avformat_find_stream_info(fmt_ctx, nullptr) < 0) {
        std::cerr << "find stream info fail" << std::endl;
        return -1;
    }
    
    // 获取音视频流对应的索引
    int audio_stream_index = -1, video_stream_index = -1;
    for (unsigned int i = 0; i < fmt_ctx->nb_streams; ++i) {
        AVStream* stream = fmt_ctx->streams[i];
        if (stream->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
            audio_stream_index = stream->index;
        } else if (stream->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
            video_stream_index = stream->index;
        }
    }
    
    // 读取压缩后的数据
    AVPacket* pkt = av_packet_alloc();
    if (pkt == nullptr) {
        std::cerr << "alloc pkt fail" << std::endl;
        return -1;
    }
    while (av_read_frame(fmt_ctx, pkt) >= 0) {
        if (pkt->stream_index == audio_stream_index) {
            std::cout << "Read audio packet, size: " << pkt->size 
                << ", pts: " << pkt->pts 
                << ", dts: " << pkt->dts 
                << ", duration: " << pkt->duration << "\n";
        } else if (pkt->stream_index == video_stream_index) {
            std::cout << "Read video packet, size: " << pkt->size 
                << ", pts: " << pkt->pts 
                << ", dts: " << pkt->dts 
                << ", duration: " << pkt->duration << "\n";
        }
        av_packet_unref(pkt);
    }
    av_packet_free(&pkt);

    // 输出文件信息，等价于 ffprobe -i cat.mp4
    av_dump_format(fmt_ctx, 0, file_name.c_str(), 0);

    // 关闭输入文件
    avformat_close_input(&fmt_ctx);

    return 0;
}
```

## 详细介绍

### AVFormatContext 结构体

`AVFormatContext` 是输入/输出文件的**核心上下文**，几乎所有和文件或流相关的信息都保存在这里。常用成员有：

- **`AVInputFormat* iformat`**
    - 输入文件的封装格式 (mp4、flv、avi 等)。
- **`AVStream** streams`**
    - 媒体中的流数组，每个 `AVStream` 表示一个视频流、音频流或字幕流。
- **`unsigned int nb_streams`**
    - 文件里一共有多少个流（常见：1 视频 + 1 音频 = 2 个流）。
- **`char* url`**
    - 输入文件名或 URL。
- **`int64_t duration`**
    - 文件总时长（以 AV_TIME_BASE = 微秒为单位）。
- **`AVDictionary* metadata`**
    - 媒体的元数据（标题、作者、编码器信息等）。
- **`AVIOContext* pb`**
    - 底层 IO 上下文，管理文件/网络的读写。

------

### avformat_open_input

```c
int avformat_open_input(
    AVFormatContext** ps,   // 输出参数：文件上下文指针
    const char* url,        // 输入文件路径或网络 URL
    AVInputFormat* fmt,     // 指定封装格式(可为 NULL, 让 FFmpeg 自动探测)
    AVDictionary** options  // 额外参数(如网络缓存大小, windos dshow 参数等，可为 NULL)
);
```

#### 作用

- 打开一个输入文件（本地文件、网络流、设备）。
- 分配并初始化 `AVFormatContext`。
- 探测输入的封装格式。

#### 返回值

- `>= 0`：成功
- `< 0`：失败（例如文件不存在）。

------

### avformat_find_stream_info

```c
int avformat_find_stream_info(
    AVFormatContext* ic,    // 输入上下文
    AVDictionary** options  // 额外参数(可为NULL)
);
```

#### 作用

- 读取一些包，分析媒体，填充 `AVStream` 的详细信息。
- 比如：视频分辨率、帧率、音频采样率、声道数等。

#### 返回值

- `>= 0`：成功
- `< 0`：失败

在 `avformat_open_input()` 之后通常要调用一次 `avformat_find_stream_info()`，否则 `AVStream` 里的编解码器参数可能是不完整的。

------

### avformat_close_input

```c
void avformat_close_input(AVFormatContext** s);
```

#### 作用

- 关闭输入文件并释放 `AVFormatContext` 及相关内存。
- 参数是 **二级指针**，调用后 `*s` 会被置为 NULL，防止野指针。

### AVPacket 结构体

- `AVPacket`：用来存放 **压缩数据包**（encoded data），比如一个 H.264 NALU 或者一个 AAC frame。它是从文件/流中读取出来的，还没解码。
- 常见来源：
    - `av_read_frame()` 从输入文件读取得到。
    - 编码器 `avcodec_receive_packet()` 输出得到。

常用成员：

- **`uint8_t* data`**：指向实际的压缩数据。
- **`int size`**：数据大小（字节数）。
- **`int stream_index`**：该数据包属于哪个流（对应 `AVFormatContext->streams[i]`）。
- **`int64_t pts`**：显示时间戳（Presentation Time Stamp）。
- **`int64_t dts`**：解码时间戳（Decoding Time Stamp）。
- **`int64_t duration`**：该包的持续时间。
- **`int64_t pos`**：在输入文件中的字节位置。

> `AVPacket` 表示**已封装的压缩数据**，解码前的最小单位。

------

#### 创建方式

堆上创建

```c
AVPacket* pkt = av_packet_alloc();
if (!pkt) {
    // 分配失败
}
```

- 使用场景：需要长期复用的 `AVPacket`，循环读取时常用。
- **释放方法**：
    - 用完数据包内容调用 `av_packet_unref(pkt);`（释放内部数据，但保留结构体以便复用）。
    - 程序结束或不再需要时调用 `av_packet_free(&pkt);`（会自动调用 `av_packet_unref`，并释放结构体本身）。

栈上创建

```c
AVPacket pkt;
av_init_packet(&pkt);  // 初始化（某些版本可省略）
pkt.data = NULL;
pkt.size = 0;
```

- 使用场景：短期临时使用。
- **释放方法**：
    - 用完数据包内容调用 `av_packet_unref(&pkt);`

------

#### 释放方法

##### av_packet_unref(AVPacket* pkt)

- 释放 `pkt` 持有的内部缓冲和 side data。
- 不会释放 `pkt` 结构体本身。
- 一般在：
    - 每次 `av_read_frame()` 循环结束时调用。
    - 每次 `avcodec_receive_packet()` 处理完后调用。

##### av_packet_free(AVPacket** pkt)

- 用于堆上分配的 `AVPacket`。
- 会先调用 `av_packet_unref()`，然后释放结构体，并把指针置为 `NULL`。
- 一般在程序结束或不再需要该 `AVPacket` 时调用。

### av_read_frame

```c
int av_read_frame(
    AVFormatContext* fmt,  // 输入文件上下文
    AVPacket* pkt          // 输出参数：读取到的数据包
);
```

#### 作用

- 从输入文件中**读取一个压缩数据包**。
- 数据可能来自视频流、音频流、字幕流。
- 常用在循环里逐个读取。

#### 参数说明

- `s`：输入文件上下文（`avformat_open_input` 得到的）。
- `pkt`：输出的 AVPacket，需要预先 `av_init_packet()` 或直接 `av_packet_alloc()`。

#### 返回值

- `>= 0`：成功读取到一个包。
- `< 0`：文件结尾（`AVERROR_EOF`）或出错。

### av_dump_format

```c
void av_dump_format(
    AVFormatContext* ic, // 输入文件上下文
    int index,           // 流索引，一般传 0
    const char* url,     // 文件名或URL，用于打印
    int is_output        // 0 = 输入文件，1 = 输出文件
);
```

#### 作用

- 打印文件的详细信息，类似于 `ffprobe` 的输出。
- 包括容器格式、流的类型、分辨率、采样率、比特率、编解码器等。
- 主要用于调试。

#### 参数说明

- `ic`：输入文件上下文。
- `index`：流索引，通常写 `0`。
- `url`：文件名或 URL，仅用于显示。
- `is_output`：是否是输出文件（一般读取文件时传 `0`）。
