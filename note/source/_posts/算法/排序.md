---
title: 排序
date: 2025-11-22 12:11:43
categories: 算法
tags: 排序
---
>[部分模板来源](https://www.acwing.com/activity/content/11/)

## 排序

> [力扣 912. 排序数组](https://leetcode.cn/problems/sort-an-array/description/)
### 快速排序
```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        quickSort(nums, 0, nums.size() - 1);
        return nums;
    }

    void quickSort(vector<int>& nums, int l, int r) {
        if (l == r) {
            return;
        }

        int x = nums[(l + r) / 2];
        int i = l - 1, j = r + 1;
        while (i < j) {
            do {
                ++i;
            } while (nums[i] < x);
            do {
                --j;
            } while (nums[j] > x);

            if (i < j) {
                swap(nums[i], nums[j]);
            }
        }

        quickSort(nums, l, j);
        quickSort(nums, j + 1, r);
    }
};
```
#### 时空复杂度

- **时间复杂度**：
    - 最优/平均情况：O(nlogn)，在平均情况下，每次划分都能将数组分成大约相等的两部分。
    - 最坏情况：O(n²)，当划分不均匀时（数组已经有序或几乎有序），每次划分的元素数接近 0 或 n - 1。
- **空间复杂度**：O(logn)，递归的深度取决于划分的层数，最优情况下递归树的高度为 logn。

### 归并排序

```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        temp.resize(nums.size());
        mergeSort(nums, 0, nums.size() - 1);
        return nums;
    }

    void mergeSort(vector<int>& nums, int l, int r) {
        if (l == r) {
            return;
        }

        int mid = (l + r) / 2;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);

        int idx = 0;
        int i = l, j = mid + 1;
        while (i <= mid && j <= r) {
            if (nums[i] <= nums[j]) {
                temp[idx++] = nums[i++];
            } else {
                temp[idx++] = nums[j++];
            }
        }

        while (i <= mid) {
            temp[idx++] = nums[i++];
        }
        while (j <= r) {
            temp[idx++] = nums[j++];
        }

        for (i = l, idx = 0; i <= r; i++, idx++) {
            nums[i] = temp[idx];
        }
    }
private:
    vector<int> temp;
};
```

#### 时空复杂度：

- **时间复杂度**：O(nlogn)，每一层递归都将数组分成两部分，且每层合并操作的时间复杂度为 O(n)。
- **空间复杂度**：O(n)，需要额外的辅助数组 `temp` 来存储临时数据。

### 堆排序

```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        int n = nums.size();
        nums.insert(nums.begin(), 0);
        heapSort(nums, n);
        nums.erase(nums.begin());
        return nums;
    }

    void heapify(vector<int>& nums, int i, int n) {
        int cur = i;
        int left = i * 2, right = left + 1;
        if (left <= n && nums[left] > nums[cur]) {
            cur = left;
        }
        if (right <= n && nums[right] > nums[cur]) {
            cur = right;
        }
        if (cur != i) {
            swap(nums[cur], nums[i]);
            heapify(nums, cur, n);
        }
    }

    void heapSort(vector<int>& nums, int n) {
        for (int i = n / 2; i >= 1; i--) {
            heapify(nums, i, n);
        }
        for (int i = 1; i < n; i++) {
            swap(nums[1], nums[n - i + 1]);
            heapify(nums, 1, n - i);
        }
    }
};
```

#### 时空复杂度：

- **时间复杂度**：O(nlogn)，每次插入和删除元素的时间复杂度为O(logn)，且需要进行 n 次操作。
- **空间复杂度**：O(1)，不需要额外的存储空间。

## 相关应用

### 快速选择

>[力扣 215. 数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        return quickChoose(nums, 0, nums.size() - 1, k);
    }

    int quickChoose(vector<int>& nums, int l, int r, int k) {
        if (l == r) {
            return nums[l];
        }

        int x = nums[(l + r) / 2];
        int i = l - 1, j = r + 1;
        while (i < j) {
            do {
                ++i;
            } while (nums[i] > x);
            do {
                --j;
            } while (nums[j] < x);
            if (i < j) {
                swap(nums[i], nums[j]);
            }
        }

        int cnt = j - l + 1;
        if (k <= cnt) {
            return quickChoose(nums, l, j, k);
        }
        return quickChoose(nums, j + 1, r, k - cnt);
    }
};
```

#### 时空复杂度：

- **时间复杂度**：
    - 最优/平均情况：O(n)，快速选择每次划分时将问题规模减少一半。
    - 最坏情况：O(n²)，当划分不均匀时，类似快速排序会退化到 O(n²)。
- **空间复杂度**：O(logn)，取决于递归的深度。

### 逆序对

> [LCR 170. 交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/)

```cpp
class Solution {
public:
    int reversePairs(vector<int>& record) {
        int n = record.size();
        temp.resize(n);
        return mergeSort(record, 0, n - 1);;
    }

    int mergeSort(vector<int>& nums, int l, int r) {
        if (l >= r) {
            return 0;
        }

        int mid = (l + r) / 2;
        int ans = mergeSort(nums, l, mid) + mergeSort(nums, mid + 1, r);
        int i = l, j = mid + 1, idx = 0;
        while (i <= mid && j <= r) {
            if (nums[i] <= nums[j]) {
                temp[idx++] = nums[i++];
            } else {
                ans += mid - i + 1;
                temp[idx++] = nums[j++];
            }
        }

        while (i <= mid) {
            temp[idx++] = nums[i++];
        }
        while (j <= r) {
            temp[idx++] = nums[j++];
        }
        for (i = 0, j = l; j <= r; j++, i++) {
            nums[j] = temp[i];
        }

        return ans;
    }
private:
    vector<int> temp;
};
```

#### 时空复杂度：

- **时间复杂度**：O(nlogn)，与归并排序类似，每次合并的时间复杂度为 O(n)，且递归树的深度为 logn。
- **空间复杂度**：O(n)，需要额外的辅助数组 `temp` 来存储临时数据。