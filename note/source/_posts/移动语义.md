---
title: 移动语义
date: 2025-11-17 23:17:18
tags: C++
---

> Q: C++11 的右值引用和移动语义是怎么工作的？为什么能提升性能？
>
> A: 右值引用（`T&&`）是 C++11 引入的一种新引用类型，用来接管“临时对象”的资源。通过 **移动语义（Move Semantics）**，程序可以在拷贝对象时**直接转移资源所有权**（如内存、文件句柄、容器内存），而不是重新分配、复制数据。这样避免了大量无意义的深拷贝操作，极大提升了性能。

------

## 🧩 左值与右值的基本概念

C++11 之前的值类别只有两种：**左值（Lvalue）和右值（Rvalue）**。C++11 之后，为了支持移动语义与完美转发，进一步细分为三种：

| 分类                                    | 名称                   | 示例                     | 特点                       |
| --------------------------------------- | ---------------------- | ------------------------ | -------------------------- |
| 左值（Lvalue）                          | 有名字、可取地址       | `int a = 10;` 中的 `a`   | 持久存在，可在赋值号左边   |
| 右值 - 纯右值（Prvalue, pure rvalue）   | 表达式临时结果或字面值 | `10`, `a + 1`, `"hello"` | 无名字、无地址、生命周期短 |
| 右值 - 将亡值（Xvalue, expiring value） | 即将被销毁、可移动的值 | `std::move(a)`           | 有资源、但即将“过期”       |

------

### 左值（Lvalue）

可以出现在赋值号左边的对象，具有持久存储。

```cpp
int a = 10;
int* p = &a;  // a 是左值，可取地址
```

------

### 纯右值（Prvalue）

表达式临时结果，没有名字、不能取地址、生命周期仅在当前语句。

```cpp
int x = a + 1;   // (a + 1) 是纯右值
foo(42);         // 42 是纯右值
```

------

### 将亡值（Xvalue）

C++11 新增类型，**是有资源的右值**，常见于：

- `std::move(x)` 产生的结果；
- 函数返回右值引用的场景。

```cpp
std::string s = "abc";
std::string t = std::move(s); // 此时 s 是将亡值
```

- `std::move(s)` 把 `s` 强制转换为右值；
- `s` 的内容可“被偷走”，属于即将销毁的对象。

## 🧱 右值引用（`T&&`）的本质

右值引用是能绑定到**右值（临时对象或将亡值）**的引用类型。

```cpp
int&& r1 = 10; // 右值
int&& r2 = a;  // 左值不能直接绑定右值引用
```

右值引用让我们能够**识别出“可移动”的对象**，从而安全地转移其内部资源。

## ⚙️ 移动语义

### 核心思想

当对象是右值（如临时对象），其资源可以直接转移而非复制。

```cpp
std::vector<int> v1 = {1, 2, 3, 4};
std::vector<int> v2 = std::move(v1); // 移动构造
```

| 操作       | 拷贝构造 | 移动构造 |
| ---------- | -------- | -------- |
| 分配新内存 | ✅        | ❌        |
| 拷贝数据   | ✅        | ❌        |
| 转移指针   | ❌        | ✅        |
| 性能       | O(n)     | O(1)     |

------

### 移动构造函数示例

```cpp
class MyString {
private:
    char* data;
    size_t size;

public:
    MyString(MyString&& other) noexcept
        : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
    }

    MyString& operator=(MyString&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            size = other.size;
            other.data = nullptr;
            other.size = 0;
        }
        return *this;
    }

    ~MyString() { 
        delete[] data; 
    }
};
```

------

## 🧠 `std::move()` 的原理

`std::move()` **不会移动任何数据**，它只是做了一个格式转换。

```cpp
template <typename T>
constexpr typename std::remove_reference<T>::type&& move(T&& t) noexcept {
    return static_cast<typename std::remove_reference<T>::type&&>(t);
}
```

> `std::move` 是一个模板函数，通过 `std::remove_reference<T>::type` 先移除`T`的引用属性（例如：若 `T` 是 `int&`，则移除后为 `int`；若 `T` 是 `int`，则移除后仍为 `int`）。然后通过 `static_cast<remove_reference_t<T>&&>` 将其无条件转换为右值（xvalue）。它本身不执行移动操作，只是改变表达式的值类别，使得在后续函数调用或构造中可以匹配到移动构造函数或移动赋值运算符。

------

## ⚙️ `std::forward()` 的原理与用途

### const T& 为什么可以绑定右值

C++ 有两种主要的引用类型：

| 类型                       | 能绑定的对象                 | 生命周期                                     |
| -------------------------- | ---------------------------- | -------------------------------------------- |
| `T&`（非常量左值引用）     | **只能绑定左值**             | 与被引用对象相同                             |
| `const T&`（常量左值引用） | **能绑定左值，也能绑定右值** | 如果绑定右值临时对象，则延长该右值的生命周期 |

而右值引用 `T&&` 则专门设计来绑定右值。

C++ 标准（[C++11 §8.5.3/5]）规定：

> A reference to const can bind to an rvalue (temporary) because the compiler can create a temporary object and extend its lifetime to the lifetime of the reference.

当你写：

```cpp
void foo(const std::string& s);
foo("hello");
```

`"hello"` 是一个右值（字面量产生的临时 `std::string` 对象）。编译器允许用一个临时对象去构造参数 `s`。因为参数是 `const &`，**不会修改这个临时对象**，所以安全。同时，**编译器会延长这个临时对象的生命周期到 `foo()` 返回为止**。

举个对比：

```cpp
void bar(std::string& s); // 非 const 引用
bar("hello");             // 编译错误
```

`"hello"` 是右值（临时对象），如果函数参数能绑定到它，就可能在函数里修改它，而这个临时对象会在语句结束就销毁，修改它是不安全的，所以标准禁止非常量左值引用绑定到右值。

| 参数类型   | 能接左值 | 能接右值 | 是否延长右值生命周期 | 能否修改对象 |
| ---------- | -------- | -------- | -------------------- | ------------ |
| `T&`       | ✅        | ❌        | 否                   | ✅            |
| `const T&` | ✅        | ✅        | ✅                    | ❌            |
| `T&&`      | ❌        | ✅        | 否（本身就是右值）   | ✅            |

> `const T&` 可以接受右值，是因为标准规定可以将右值（临时对象）绑定到常量左值引用上，这样既能安全地访问（不会修改），又能延长右值的生命周期到引用作用域结束。

### 万能引用

**定义：**当模板参数使用 `T&&` 且发生**类型推导**时，`T&&` 并不是简单的右值引用，而是“万能引用”。

```cpp
template <typename T>
void func(T&& x) { ... }  // T&& 是万能引用
```

推导规则：

| 实参类型    | 推导出的 T | 参数类型                  |
| ----------- | ---------- | ------------------------- |
| 左值 `int&` | `int&`     | `int& &&` → 折叠为 `int&` |
| 右值 `int`  | `int`      | `int&&`                   |

这依赖于 C++ 的**引用折叠规则**：

| 组合     | 折叠结果 |
| -------- | -------- |
| `T& &`   | `T&`     |
| `T& &&`  | `T&`     |
| `T&& &`  | `T&`     |
| `T&& &&` | `T&&`    |

> ✅ 万能引用能自动区分传入的是左值还是右值，这也是完美转发机制的基础。

**完美转发（Perfect Forwarding）**允许模板函数在调用下层函数时保留参数的值类别（左值 / 右值）。

```cpp
template <typename T>
void wrapper(T&& arg) {
    foo(std::forward<T>(arg));  // 保留原始值类别
}
```

#### 简化版源码

```cpp
template <typename T>
constexpr T&& forward(typename std::remove_reference<T>::type& t) noexcept {
    return static_cast<T&&>(t);
}
```

与 `std::move` 不同的是：

- `std::move` **无条件地**转为右值；
- `std::forward` **有条件地**：
    - 若 `T` 是左值引用 → 返回左值；
    - 若 `T` 是右值引用 → 返回右值。

> 即：`std::forward` = “**带条件的 std::move**”。

------

#### 举例说明

```cpp
void foo(int& l) { 
    std::cout << "Lvalue\n"; 
}
void foo(int&& r) { 
    std::cout << "Rvalue\n"; 
}

template<typename T>
void bar(T&& x) {
    foo(std::forward<T>(x)); // 根据传入值类别自动选择
}
int a = 0;
bar(a);        // 输出 Lvalue
bar(10);       // 输出 Rvalue

// C++ 规则中非常重要的一点：任何有名称的变量（包括右值引用）都是左值。
template<typename T>
void bar2(T&& x) {
    foo(x);
}
bar2(a);        // 输出 Lvalue
bar2(10);       // 输出 Lvalue
```

------

## 🏁 总结表格

| 特性           | 左值引用 `T&` | 右值引用 `T&&` | 万能引用 `T&&`（模板推导） |
| -------------- | ------------- | -------------- | -------------------------- |
| 可绑定对象     | 左值          | 右值           | 左值或右值                 |
| 是否能移动资源 | ❌             | ✅              | ✅（右值时）                |
| 是否可转发     | ❌             | ❌              | ✅（配合 `std::forward`）   |
| 常用函数       | -             | `std::move`    | `std::forward`             |
| 编译器识别     | 恒为左值      | 仅右值绑定     | 自动判断                   |
| 实现基础       | 普通引用      | 移动语义       | 引用折叠+完美转发          |
