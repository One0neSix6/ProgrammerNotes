---
title: 模板编程
date: 2025-11-28 10:59:37
categories: 编程语言
tags: C++
---

# 模板编程

> C++ 的模板编程（Template Programming）是一种强大的编程技术，可以让程序员编写通用的、类型安全的代码（在编译时根据类型生成代码）。主要分为两种类型：**函数模板**和**类模板**。

## 模板的基本概念

C++ 的模板可以将类型作为参数传递给函数或类，使得相同的代码可以作用于不同的数据类型。模板的核心思想是让代码在编译时决定具体类型，从而避免了代码重复。

### 函数模板

函数模板允许根据传入的类型来生成对应的函数。

```cpp
template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    int x = 5, y = 10;
    std::cout << add(x, y) << std::endl; // 输出 15

    double m = 3.5, n = 4.5;
    std::cout << add(m, n) << std::endl; // 输出 8.0
}
```

上面的例子中，`add` 函数是一个模板函数，`T` 是模板参数，在编译时会根据调用的类型自动生成相应的函数。

### 类模板

类模板是通过模板来定义类，可以为不同的数据类型创建相同的类。

```cpp
template <typename T>
class Box {
public:
    Box(T value) : value(value) {}
    T getValue() { 
        return value; 
    }
private:
    T value;
};

int main() {
    Box<int> intBox(10);
    std::cout << intBox.getValue() << std::endl; // 输出 10

    Box<double> doubleBox(3.14);
    std::cout << doubleBox.getValue() << std::endl; // 输出 3.14
}
```

`Box` 是一个模板类，它接受一个类型参数 `T`，并且根据不同的类型生成不同的类实例。

## 模板的特性与高级用法

### 模板特化

模板特化是指为特定的类型提供不同的实现。模板特化可以分为**完全特化**和**偏特化**。

#### 完全特化

当我们需要为某个特定类型定义不同的行为时，可以使用完全特化：

```cpp
template <typename T>
class Box {
public:
    T value;
    Box(T v) : value(v) {}
    void print() { std::cout << "Generic Box: " << value << std::endl; }
};

// 完全特化为 int 类型
template <>
class Box<int> {
public:
    int value;
    Box(int v) : value(v) {}
    void print() { std::cout << "Specialized Box for int: " << value << std::endl; }
};

int main() {
    Box<double> box1(3.14);
    box1.print();  // 输出 Generic Box: 3.14

    Box<int> box2(10);
    box2.print();  // 输出 Specialized Box for int: 10
}
```

#### 偏特化

偏特化是指对模板进行部分特化，用以处理某些特殊类型或类型组合。

```cpp
template <typename T, typename U>
class Pair {
public:
    T first;
    U second;
    Pair(T f, U s) : first(f), second(s) {}
};

// 偏特化：当 T 和 U 都是指针类型时
template <typename T, typename U>
class Pair<T*, U*> {
public:
    T* first;
    U* second;
    Pair(T* f, U* s) : first(f), second(s) {}
    void print() { std::cout << "Pointer pair: " << *first << ", " << *second << std::endl; }
};

int main() {
    int a = 10, b = 20;
    Pair<int*, int*> ptrPair(&a, &b);
    ptrPair.print();  // 输出 Pointer pair: 10, 20
}
```

### 模板的递归与元编程

C++ 模板支持递归，可以利用模板实现一些编译时计算或类型推导的功能。例如，编写一个计算阶乘的模板：

```cpp
template <int N>
struct Factorial {
    static const int value = N * Factorial<N - 1>::value;
};

template <>
struct Factorial<0> {
    static const int value = 1;
};

int main() {
    std::cout << Factorial<5>::value << std::endl; // 输出 120
}
```

在这个例子中，`Factorial` 是一个递归模板，它计算了整数的阶乘值。模板元编程让我们可以在编译时进行计算，从而提高程序的效率。

### 类型萃取

类型萃取（Type Traits）是模板编程中的一种常用技巧，用于在编译时获取类型的特征。C++ 标准库提供了许多类型萃取工具，如 `std::is_integral` 和 `std::is_floating_point` 等。

```cpp
#include <iostream>
#include <type_traits>

template <typename T>
void check_type(T value) {
    if (std::is_integral<T>::value) {
        std::cout << "Integral type\n";
    } else if (std::is_floating_point<T>::value) {
        std::cout << "Floating point type\n";
    } else if (std::is_pointer<T>::value) {
        std::cout << "Pointer type\n";
    } else {
        std::cout << "Other type\n";
    }
}

int main() {
    check_type(10);              // 输出 Integral type
    check_type(3.14);            // 输出 Floating point type
    check_type(nullptr);         // 输出 Pointer type
    check_type("Hello, world!"); // 输出 Other type
}

```

常用的类型萃取如下：

| 类型萃取工具                            | 功能描述                                                |
| --------------------------------------- | ------------------------------------------------------- |
| `std::is_integral<T>::value`            | 判断类型 `T` 是否为整数类型（`char`、`int`、`long` 等） |
| `std::is_floating_point<T>::value`      | 判断类型 `T` 是否为浮动点类型（`float`、`double` 等）   |
| `std::is_void<T>::value`                | 判断类型 `T` 是否为 `void` 类型                         |
| `std::is_pointer<T>::value`             | 判断类型 `T` 是否为指针类型                             |
| `std::is_reference<T>::value`           | 判断类型 `T` 是否为引用类型                             |
| `std::is_const<T>::value`               | 判断类型 `T` 是否为 `const` 类型                        |
| `std::is_lvalue_reference<T>::value`    | 判断类型 `T` 是否为左值引用类型                         |
| `std::is_rvalue_reference<T>::value`    | 判断类型 `T` 是否为右值引用类型                         |
| `std::is_signed<T>::value`              | 判断类型 `T` 是否为带符号类型（如 `int`、`float`）      |
| `std::is_unsigned<T>::value`            | 判断类型 `T` 是否为无符号类型（如 `unsigned int`）      |
| `std::is_same<T, U>::value`             | 判断类型 `T` 和类型 `U` 是否相同                        |
| `std::is_base_of<Base, Derived>::value` | 判断类型 `Derived` 是否是 `Base` 的派生类               |
| `std::is_convertible<T, U>::value`      | 判断类型 `T` 是否可以转换为类型 `U`                     |

## 模板的性能与优化

模板编程可以极大地提升代码的复用性，但也会引入一些性能和编译时间上的开销。例如，模板的实例化会导致生成大量的代码，可能增加编译时间和可执行文件的体积。为了优化性能，常用的技巧包括：

- **避免过度特化**：过度使用模板特化会导致代码膨胀，增加编译时间和执行时的负担。
- **模板元编程**：使用编译时计算减少运行时的计算量，提升效率。
- **显式实例化**：通过显式实例化模板，避免多次重复实例化。

# SFINAE

SFINAE 的全称是 「Substitution Failure Is Not An Error」，即替换失败不是错误，是 C++ 模板系统的一个规则。

> 当编译器在进行模板实参推导（substitution）时，如果把实参代入模板导致某个候选模板无效，这个候选会被悄悄丢弃，而不是立刻报编译错误。然后编译器会继续看其他候选，如果还有合适的，就选一个；如果一个都选不出来，才报错。

这个规则是很多特性的基础，比如：

- 根据类型特性（是否为整数、是否可拷贝等）选择不同重载；
- 只在某些条件满足时启用一个函数或成员；

SFINAE 通常由 `std::enable_if` 来实现。

## std::enable_if

标准只规定了行为，不规定实现方式，但各大标准库的实现都非常接近，典型实现如下（C++11）：

```cpp
namespace std {

template <bool B, class T = void>
struct enable_if {};              // 主模板：什么都没有

template <class T>
struct enable_if<true, T> {       // 特化：当 B = true
    using type = T;
};

} // namespace std
```

1. 主模板 `enable_if<B, T>` 是一个 **空的模板结构体**，里面没有别名 `type`。
    - 当 `B = false` 时，会匹配到这个主模板。
    - 此时如果你写 `typename std::enable_if<false, T>::type`，由于 `type` 不存在，模板替换失败。
2. 当 `B = true` 时，偏特化 `enable_if<true, T>` 生效，里面定义了 `using type = T;`。
    - 于是 `std::enable_if<true, T>::type` 是合法的类型别名。
3. 当你在函数模板返回类型、默认模板参数、参数类型等参与模板实参推导的位置使用 `std::enable_if` 时：
    - 若 `B = true`，一切正常；
    - 若 `B = false`，编译器在那一条重载上替换失败，这个重载就从候选集中消失，而不是全局报错。

因此，`enable_if` 的核心就是：**用有无 `::type` 这个成员，来控制模板替换是否成功**。

## std::enable_if_t

从 C++14 开始，标准库引入了各种 `_t`、`_v` 别名，来简化 `typename ...::type` 这种长串写法。

对于 `std::enable_if_t`，典型实现是：

```cpp
namespace std {

template <bool B, class T = void>
using enable_if_t = typename enable_if<B, T>::type;

} // namespace std
```

这只是对 `typename enable_if<B, T>::type` 的一个 alias template：

- 写法更短，尤其是当嵌套使用多个 type traits 时可读性会好很多；
- 功能上完全等价。

例子：

```cpp
// C++11 写法
template <class T>
typename std::enable_if<std::is_integral<T>::value, int>::type
foo(T x);

// C++14 写法
template <class T>
std::enable_if_t<std::is_integral<T>::value, int>
foo(T x);
```

两者语义完全一样，只是后者少写了 `typename` 和 `::type`。

## enable_if 常见用法

### 用在函数返回类型

```cpp
#include <type_traits>

// 仅对整数类型启用这个重载
template <class T>
std::enable_if_t<std::is_integral<T>::value, int>
sum(T a, T b) {
    return static_cast<int>(a + b);
}

// 仅对浮点类型启用这个重载
template <class T>
std::enable_if_t<std::is_floating_point<T>::value, double>
sum(T a, T b) {
    return static_cast<double>(a + b);
}
```

调用：

```cpp
sum(1, 2);       // 匹配整数版本
sum(1.0, 2.0);   // 匹配浮点版本
```

这里的关键点：

- 当 `T` 为 `int` 时：
    - 对于第一个模板：`std::is_integral<int>::value == true`，`enable_if_t<true, int>` 等于 `int`，函数返回类型合法；
    - 对于第二个模板：`std::is_floating_point<int>::value == false`，`enable_if_t<false, double>` 替换失败，该重载丢弃。
- 当 `T` 为 `double` 时，情况反过来。

### 用在模板参数列表

```cpp
template <
    class T,
    class = std::enable_if_t<std::is_integral<T>::value>
>
int sum(T a, T b) {
    return static_cast<int>(a + b);
}
```

这里的技巧是：

- 第 2 个模板参数是一个无名类型参数，默认值是 `enable_if_t<...>`；
- 当条件为 `false` 时，这个默认类型不存在，模板替换失败，整个函数模板失效；
- 又因为这个参数是未使用的哑参数，调用时不需要显式传入，不影响使用体验。

类似这种带非类型参数的写法：

```cpp
template <
    class T,
    std::enable_if_t<std::is_integral<T>::value, int> = 0
>
int sum(T a, T b) {
    return static_cast<int>(a + b);
}
```

这里 `enable_if_t<..., int>` 在 `true` 时等于 `int`，模板参数变成一个整型参数，默认值为 `0`；为 `false` 时替换失败。

### 用在成员函数、构造函数

`enable_if` 也经常用来约束类成员，尤其是构造函数和模板成员：

```cpp
struct Foo {
    int x;

    // 仅当 T 是整数时启用该构造函数
    template <class T,
              class = std::enable_if_t<std::is_integral<T>::value>>
    Foo(T v) : x(static_cast<int>(v)) {}
};
```

如果你写 `Foo f(3.14);`，则该构造函数模板替换失败，编译器会去找别的构造函数；如果没有其它可用的，就报错。

## SFINAE 的语境

1. **SFINAE 只发生在模板实参推导阶段**
    - 也就是编译器在“推导模板参数”的时候，用实参去替换模板里的形参。
    - 如果错误发生在推导之后的普通实例化阶段（比如强行实例化一个不合法的表达式），通常就是硬错误，而不是 SFINAE。
2. **只有某些上下文才是 SFINAE 上下文**，大致包括：
    - 函数模板的参数类型、返回类型、模板参数默认值；
    - `decltype`、`sizeof`、某些表达式里依赖模板参数的地方，只要出现在用于推导的上下文中。

简单对比：

```cpp
// 1. 这是 SFINAE 上下文
template <class T>
auto test(T t) -> decltype(t.foo(), void()) {
    // ...
}

// 2. 这不是 SFINAE 上下文
template <class T>
auto test2(T t) {
    t.foo();  // 如果 T 没有 foo()，这里是硬错误，而不是 SFINAE
}
```

## concepts

从 C++20 开始，有了 concepts 和 requires 子句之后，很多原本用 `enable_if` 做的事情，可以用更可读的语法表达：

```cpp
template <class T>
requires std::integral<T>
int sum(T a, T b) {
    return static_cast<int>(a + b);
}
```

这本质上也是通过约束系统影响重载决议，但语义更直观、错误信息也更友好。
在新代码中，如果可以使用 C++20，优先考虑 concepts；但理解 `std::enable_if` 和 SFINAE 仍然很重要，因为：

- 现有大量库代码（包括标准库）依然大量使用 SFINAE；
- 很多 type traits 和元编程工具内部实现基于 SFINAE；
- 一些场景 concepts 还不完全覆盖，SFINAE 依然是有力补充。
