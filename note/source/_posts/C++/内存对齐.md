---
title: 内存对齐
date: 2025-11-17 20:12:41
categories: 编程语言
tags: C++
---
>Q: 解释内存对齐的作用及原理，为什么对齐会影响性能？
>
>A: 内存对齐是用空间换时间的一种设计，主要是让数据存放在特定的内存地址上，这样 CPU 读取数据更高效。原理是 CPU 按固定字长（32 位 4 字节、64 位 8 字节）访问内存，要是数据没对齐，可能得读多次再拼接，对齐后一次就能读完整个数据。

## 🧩 什么是内存对齐

### 📘 定义

> **内存对齐**指的是：编译器在为变量或结构体分配内存时，会按照一定的规则让**变量的起始地址满足某种对齐条件**，即变量的地址是某个对齐值的整数倍。

------

### 📊 举个例子

假设我们有这样一个结构体：

```cpp
struct A {
    char a;   // 1字节
    int b;    // 4字节
    short c;  // 2字节
};
```

如果**不对齐**，理论上排列是：

```text
| a(1B) | b(4B) | c(2B) |   共 7 字节
```

但实际你会发现：

```cpp
sizeof(A) == 12;  // 不是 7！
```

------

## 🧱 对齐规则

常见编译器（如 GCC、MSVC、Clang）通常采用以下规则：

1. **每个成员变量的地址必须是其类型大小的整数倍**
    - `char` 对齐到 1 字节边界；
    - `short` 对齐到 2 字节边界；
    - `int`、`float` 对齐到 4 字节；
    - `double`、`long long` 对齐到 8 字节（在 64 位机）。
2. **结构体整体大小必须是最大对齐量的整数倍**
    - 最大对齐量 = 成员中对齐要求最大的那个。
3. **继承相关**
    - 派生类的对齐系数是基类对齐系数与派生类新增成员对齐系数中的最大值；
    - 含有虚函数的类会生成虚函数表指针（vptr），vptr 的对齐系数通常与指针类型相同（64 位系统为 8 字节），可能影响类的对齐和大小。

------

### ⚙️ 例子：上面的结构体实际布局

```text
地址偏移    内容
0           a (char，占1字节)
1~3         填充(padding 3字节)     // 让下一个int按4字节对齐
4~7         b (int，占4字节)
8~9         c (short，占2字节)
10~11       填充(padding 2字节)    // 让整个结构体对齐到4字节边界
-----------------------------------
总大小 = 12 字节
```

------

## 🧮 为什么要内存对齐

### ⚡ CPU 总线宽度 & 内存访问单位

CPU 访问内存不是1 字节 1 字节地拿，而是一次性以总线宽度为单位访问。

比如：

- 32 位 CPU 的总线宽度是 4 字节；
- 64 位 CPU 的总线宽度是 8 字节。

也就是说 CPU 一次从内存读取的数据宽度是固定的，比如 4B 或 8B。

------

### ⚠️ 如果数据不对齐，会怎样？

假设在 32 位 CPU 上，你有一个 `int`（4字节）放在内存地址 `0x0003` 开始：

```text
地址     内容
0x0000  [ ... ]
0x0003  int 开始 (错位)
0x0006  int 结束
```

CPU 想一次性读取这个 int（4 字节），但它发现——跨越了两个访问单元（0x0000 - 0x0003、0x0004 - 0x0007），于是它必须：

- 第一次读 0x0000 ~ 0x0003；
- 第二次读 0x0004 ~ 0x0007；
- 然后拼接两个结果，取出中间 4 个字节。

一次本可以完成的读操作，要拆成两次，CPU 要做额外的内存访问、数据拼接，导致性能下降。

如果 `int` 是从 0x0004 开始：

```text
地址：0x0004 ~ 0x0007
```

CPU 一次就能从总线上把这 4 个字节读进寄存器，不跨边界，提高访问速度。

------

## 💡 对齐与性能的关系

对齐 = CPU 一次访问完成

- 少一次总线访问；
- 少一次合并操作；
- 更好的缓存命中（cache line aligned）。

不对齐 = 更多访存操作

- CPU 要分两次甚至多次访问；
- 对一些架构（比如 ARM、MIPS），不对齐访问可能直接触发 **总线错误（Bus Error）**；
- 在 x86 上虽然允许不对齐访问，但性能会下降 20%～50%。

## 🔧 改变对齐规则的方法

有时我们不想浪费空间，可以用编译器指令或关键字调整。

### #pragma pack(n)

控制最大对齐字节数，例如：

```cpp
#pragma pack(1)
struct A {
    char a;
    int b;
    short c;
};
#pragma pack()
```

此时所有成员**按 1 字节对齐**，`sizeof(A) == 7`。

但要注意：

> **性能可能下降**，因为访问 b/c 时不再对齐。

------

### alignas 关键字

手动指定对齐要求：

```cpp
struct alignas(16) Vec4 {
    float x, y, z, w;
};
```

保证对象起始地址为 16 字节对齐。
常用于 SIMD 指令（如 SSE/AVX），这些指令要求数据地址必须对齐到 16/32 字节边界。

------

## 🧠 为什么现代编译器坚持默认对齐

总结下来原因有三点：

| 原因           | 描述                                                     |
| -------------- | -------------------------------------------------------- |
| ✅ CPU 架构要求 | 某些 CPU 不能读写非对齐内存                              |
| ⚡ 性能考虑     | 避免多次访存、拼接、Cache Miss                           |
| 💾 兼容性       | 保证跨平台结构体一致性（尤其是网络通信、二进制文件格式） |

## 🏁 总结

| 项目       | 对齐前   | 对齐后         | 性能影响       |
| ---------- | -------- | -------------- | -------------- |
| 地址边界   | 任意     | 按类型大小对齐 | 提升访问效率   |
| 总线访问   | 多次拼接 | 一次完成       | 减少访存次数   |
| Cache 命中 | 差       | 高             | 减少缓存失效   |
| 程序大小   | 小       | 略大           | 空间换时间     |
| 可移植性   | 差       | 高             | 结构体兼容性强 |
