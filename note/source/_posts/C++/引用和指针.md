---
title: 引用和指针
date: 2025-11-21 10:20:31
categories: 编程语言
tags: C++
---

## 引用

在 C++ 中，引用是一个非常重要的概念，它允许创建一个变量的别名，使得可以通过这个别名来访问原变量。引用通常用于简化代码，尤其在函数传参和返回值中，能有效避免不必要的拷贝操作。

### **引用的基本定义**

引用是一个变量的别名，它和原变量共享同一个内存位置。引用必须在定义时初始化，并且一旦绑定到某个变量后，它就不能再绑定到其他变量。

- **声明**：引用的声明通过 `&` 符号进行。例如，`int& r = x;` 表示 `r` 是 `x` 的引用。
- **引用的特性**：
    - **初始化**：引用在声明时必须被初始化。
    - **别名**：引用是原变量的别名，任何对引用的操作都直接影响原变量。
    - **不可更改绑定**：引用一旦绑定到某个变量，就不能改变绑定到其他变量。

#### 示例：

```cpp
int x = 10;
int& r = x;  // r 是 x 的引用
r = 20;      // r 改变了 x 的值
std::cout << x << std::endl;  // 输出 20
```

在这个例子中，`r` 是 `x` 的引用，修改 `r` 会直接修改 `x` 的值。

### **引用的类型**

- **左值引用**（Lvalue References）：通常用于函数参数传递，或者作为返回值。

```cpp
int x = 10;
int& r = x;  // r 是 x 的左值引用
```

- **右值引用**（Rvalue References）：C++11 引入的概念，用于支持移动语义，通常用于资源的转移和临时对象的处理。右值引用使用 `&&` 来声明。例如，`int &&r = 10;`。

```cpp
int&& r = 10;  // r 是右值引用
```

### **常量引用**

常量引用是指引用所指向的对象不能通过该引用进行修改。常量引用的主要作用是允许引用临时对象，同时避免不必要的复制操作。

- **声明**：`const T&` 表示常量引用，`T` 是类型，`&` 表示引用，`const` 表示引用所指向的值不可修改。

```cpp
int x = 10;
const int& r = x;  // 常量引用，不能修改 r 所指向的值
```

常量引用的一大优势是它允许我们传递临时对象或常量，而无需创建副本：

```cpp
void print(const std::string& s) {
    std::cout << s << std::endl;
}

print("Hello, World!");  // 传递临时字符串，不需要复制
```

### **引用作为函数参数传递**

引用常用于函数参数传递，尤其是当你需要修改传入的变量或者避免复制大对象时。传递引用比传递对象的副本要高效，因为它避免了数据的复制。

- **值传递**：函数接收的是参数的副本，修改副本不会影响原始数据。
- **引用传递**：函数接收的是参数的引用，修改引用会直接影响原始数据。

#### 示例：

```cpp
void byValue(int x) {
    x = 20;  // 只修改副本
}

void byReference(int& r) {
    r = 20;  // 修改原始数据
}

int a = 10;
byValue(a);
std::cout << a << std::endl;  // 输出 10，因为值传递没有影响原始变量

byReference(a);
std::cout << a << std::endl;  // 输出 20，因为引用传递修改了原始数据
```

### **引用作为函数返回值**

引用也可以作为函数的返回类型，用于返回某个变量的引用。这种方式可以避免不必要的拷贝操作，尤其是对于大型数据结构或者容器类型时非常有效。但返回局部变量的引用是不安全的，因为局部变量在函数结束时会被销毁。

#### 示例：

```cpp
int x = 10;

int& getRef() {
    return x;  // 返回 x 的引用
}

int main() {
    getRef() = 20;  // 修改 x 的值
    std::cout << x << std::endl;  // 输出 20
    return 0;
}
```

### **引用与函数模板**

引用在函数模板中也有很多应用，尤其是在传递大型对象时，可以避免复制。以下是一个利用引用避免复制的例子：

```cpp
template <typename T>
void print(const T& value) {
    std::cout << value << std::endl;
}

int main() {
    int x = 42;
    print(x);  // 通过引用传递 x，避免复制
    return 0;
}
```

## 指针

### **基本使用**

指针是一个变量，它存储另一个变量的内存地址。通过指针，我们可以间接访问变量的值。

* **声明**：指针变量的声明以 `*` 表示。例如，`int* p` 声明了一个指向 `int` 类型的指针 `p`。
* **初始化**：可以通过地址运算符 `&` 获取一个变量的地址。例如，`int x = 10; int* p = &x;` 将变量 `x` 的地址赋给指针 `p`。
* **解引用**：通过 `*` 解引用指针，访问它所指向的值。例如，`int y = *p;` 将指针 `p` 所指向的值赋给 `y`。

```cpp
int x = 10;
int* p = &x;
std::cout << "p points to: " << *p << std::endl;  // 输出 10
```

### **指针的大小**

指针本身占用的内存大小通常与操作系统的位数有关（32 位操作系统上的指针大小通常为 4 字节，64 位操作系统上的指针大小通常为 8 字节）。指针的大小是固定的，与它指向的数据类型无关。例如：

```cpp
int* p;
std::cout << sizeof(p) << std::endl;  // 输出指针大小，通常为 8 字节（64 位系统）
```

### **野指针和悬空指针**

* **野指针**：指向未知或非法内存位置的指针。它可能没有被初始化或者被错误地修改过，因此访问它会导致程序错误或崩溃。

```cpp
int* p;  // p 是野指针，未初始化
std::cout << *p << std::endl;  // 未定义行为
```

* **悬空指针**：指针曾经指向一个有效的内存位置，但该位置的内容已经被释放，导致指针指向一个无效的内存位置。

```cpp
int* p = new int(10);
delete p;  // p 成为悬空指针
std::cout << *p << std::endl;  // 未定义行为
```

**解决办法**

- 指针声明时初始化为 `nullptr`
- 使用指针变量前判空
- 释放内存后将对应指针变量赋为 `nullptr`
- 使用智能指针

### **常量指针和指针常量**

* **常量指针**：指向的内容不可修改，但指针本身可以指向不同的地址。

```cpp
int x = 10, y = 20;
int* const p = &x;  // 常量指针，指针不可变
*p = 15;  // 可以修改 *p 指向的值
p = &y;  // 错误：指针本身不能变
```

* **指针常量**：指针本身不可修改，但可以修改指针指向的内容。

```cpp
const int* p = &x;  // 指针常量，不能修改 *p 指向的值
*p = 15;  // 错误：无法修改 *p 指向的值
p = &y;  // 可以改变 p 指向的地址
```

* **常量指针常量**：指针和它所指向的内容都不可修改。

```cpp
const int *const p = &x;  // 常量指针常量，不能修改 *p 或 p
```

### **函数指针与指针函数**

* **函数指针**：指向函数的指针，可以用来调用相应的函数。

```cpp
void foo() {
    std::cout << "Hello, World!" << std::endl;
}

void (*fptr)() = foo;
fptr();  // 调用 foo()
```

* **指针函数**：返回值为指针的函数。

```cpp
int* ptrFunc() {
    int *p = new int(10);
    return p;
}

int *p = ptrFunc();  // p 现在指向动态分配的内存
```

## 对比
### **指针和引用的区别**

指针和引用都可以用于间接访问变量，但有几个显著的区别：

* **声明**：

  * 指针：`int* p;`
  * 引用：`int& r = x;`
* **指向对象**：

  * 指针可以指向 `nullptr`，指针可以改变指向。
  * 引用必须初始化，并且一旦绑定到某个变量，就不能改变绑定对象。
* **解引用**：

  * 指针需要使用 `*` 进行解引用。
  * 引用直接使用即可，不需要解引用操作。

示例：

```cpp
int x = 10;
int* p = &x;
int& r = x;

std::cout << *p << std::endl;  // 10
std::cout << r << std::endl;   // 10
```

### **值传递、引用传递和指针传递的区别**

* **值传递**：函数接收到的是实际参数的副本，有拷贝开销，修改副本不会影响原始数据。

```cpp
void func(int x) {
    x = 20;  // 只修改副本，不影响原始数据
}

int a = 10;
func(a);
std::cout << a << std::endl;  // 输出 10
```

* **引用传递**：函数接收到的是实际参数的引用，无拷贝开销，可以修改原始数据。

```cpp
void func(int& x) {
    x = 20;  // 直接修改原始数据
}

int a = 10;
func(a);
std::cout << a << std::endl;  // 输出 20
```

* **指针传递**：函数接收到的是实际参数的指针，无拷贝开销，可以通过指针修改原始数据。

```cpp
void func(int* x) {
    *x = 20;  // 通过指针修改原始数据
}

int a = 10;
func(&a);
std::cout << a << std::endl;  // 输出 20
```

## 扩展

### void 指针

`void*` 是 C++ 中的一种特殊指针类型，称为 **void 指针**。它是指向不特定类型的指针，意味着它不指向任何特定类型的数据。由于 `void` 是一种不具备明确类型的类型，`void*` 能够指向任何类型的数据，这使得它在一些需要通用数据处理的场景中非常有用。

#### 基本概念

`void*` 是一种 **通用指针类型**，它可以指向任何数据类型。然而，由于 `void` 类型本身没有大小和具体类型，`void*` 不能直接解引用或进行指针算术操作。为了使用 `void*` 指针指向的数据，我们通常需要将它转换为另一个已知类型的指针。

#### 用途

- **通用指针**：`void*` 常用于函数的参数中，用于接收任何类型的数据。例如，C 标准库中的 `malloc` 函数返回的是 `void*`，它可以指向任何类型的内存块。
- **接口设计**：在设计一些库或接口时，可以使用 `void*` 来实现通用接口，使得函数或数据结构可以处理不同类型的数据。
- **内存操作**：在一些底层内存管理的操作中，`void*` 常用于表示通用的内存区域。

#### 使用方式

由于 `void*` 是通用指针类型，它可以指向任何类型的数据。例如：

```cpp
int x = 10;
double y = 3.14;

void* ptr;

ptr = &x;  // 指向 int 类型的变量
std::cout << *((int*)ptr) << std::endl;  // 输出 10

ptr = &y;  // 指向 double 类型的变量
std::cout << *((double*)ptr) << std::endl;  // 输出 3.14
```

在上面的例子中，`ptr` 是一个 `void*` 指针，它可以指向 `int` 类型和 `double` 类型的数据。在使用 `void*` 时，我们需要通过类型转换将其转换为特定类型的指针，然后才能解引用。

在 C 语言中，`malloc` 函数用于动态分配内存，它返回一个 `void*` 类型的指针：

```cpp
int* arr = (int*)malloc(10 * sizeof(int));  // 使用 void* 来指向内存块
arr[0] = 10;
std::cout << arr[0] << std::endl;  // 输出 10
free(arr);
```

尽管在 C++ 中可以直接使用 `new` 和 `delete` 来替代 `malloc` 和 `free`，但 `void*` 在低级内存操作中仍然非常常见。

`void*` 可作为函数参数，用来传递不同类型的数据。例如，某些库函数（如 `qsort`）会使用 `void*` 来接收不同类型的数据：

```cpp
void print(void* data, const char* type) {
    if (strcmp(type, "int") == 0) {
        std::cout << *((int*)data) << std::endl;
    } else if (strcmp(type, "double") == 0) {
        std::cout << *((double*)data) << std::endl;
    }
}

int x = 10;
double y = 3.14;

print(&x, "int");
print(&y, "double");
```

在上面的代码中，`print` 函数通过 `void*` 参数来处理不同类型的数据。函数内部需要根据数据类型使用类型转换来正确访问数据。

#### **局限性**

虽然 `void*` 是通用的指针类型，但它有一些局限性：

- **不能直接解引用**：因为 `void*` 没有类型信息，编译器无法知道它指向的数据类型，因此不能直接解引用 `void*` 指针。必须先将它转换为具体类型的指针。
- **不能进行指针算术操作**：`void*` 指针不具备大小，因此无法进行指针算术操作（例如，`++` 或 `--`）。在进行指针算术时，必须将 `void*` 转换为具体类型的指针。
- **类型安全**：使用 `void*` 时，类型信息丢失，容易出现类型转换错误，从而导致未定义行为。

#### **总结**

- `void*` 是一个通用指针类型，可以指向任何类型的数据。
- 使用 `void*` 可以在不确定数据类型的情况下处理指针。
- 为了使用 `void*` 指针指向的数据，通常需要进行类型转换。
- `void*` 不能直接解引用或进行指针算术操作，需要将其转换为具体类型的指针后才能进行操作。
- 在现代 C++ 编程中，尽量使用类型安全的智能指针来代替 `void*`，以提高代码的可维护性和安全性。

在 C++ 中，指针算术操作（Pointer Arithmetic）是指对指针进行加法、减法等操作，来进行内存地址的偏移和定位。指针算术操作是 C 和 C++ 中的一个非常有用的特性，它通常用于数组操作、内存管理等场景。

### 指针算术操作

#### 基本规则

- 对指针 `p` 执行 `p + n` 操作时，指针将向前（增加）移动 `n * sizeof(type)` 字节的距离。
- 对指针 `p` 执行 `p - n` 操作时，指针将向后（减少）移动 `n * sizeof(type)` 字节的距离。
- 指针之间可以进行减法运算，得到的是它们之间的元素数量，而不是字节数。

#### 指针算术操作的类型

##### 指针与整数相加或相减

- **指针加整数**：指针可以与整数相加，指针的地址会根据类型的大小进行调整。

    ```cpp
    int arr[] = {10, 20, 30, 40};
    int* p = arr; // p 现在指向 arr[0]
    
    p = p + 2;  // p 现在指向 arr[2]
    std::cout << *p << std::endl;  // 输出 30
    ```

- **指针减整数**：指针也可以与整数相减，指针会按类型大小减少。

    ```cpp
    int arr[] = {10, 20, 30, 40};
    int* p = &arr[3];
    
    p = p - 1;  // p 现在指向 arr[2]
    std::cout << *p << std::endl;  // 输出 30
    ```

##### 指针间的减法操作

- **用法**：指针间的减法操作用于计算两个指针之间的元素个数。假设 `p1` 和 `p2` 都指向同一个数组的元素，`p2 - p1` 会返回它们之间的元素个数，而不是字节数。

    ```cpp
    int arr[] = {10, 20, 30, 40};
    int* p1 = &arr[0];
    int* p2 = &arr[3];
    
    int diff = p2 - p1;  // diff 是 3，因为 p2 - p1 是指针之间的元素个数
    std::cout << diff << std::endl;  // 输出 3
    ```

- **背后的机制**：指针之间的差值计算是按元素进行的，而不是按字节。当我们计算 `p2 - p1` 时，得到的是它们之间的元素个数，而不是字节数。对于 `int*` 类型的指针，差值是以 `sizeof(int)` 为单位的。

#### 注意事项

1. **指针越界**：指针算术操作可能导致指针越界，即指向数组之外的内存区域。越界访问会导致未定义行为，进行指针算术时，必须确保指针在有效范围内。
2. **指针算术操作仅适用于同类型指针**：指针算术操作只能在指向相同类型的指针之间进行。不能对不同类型的指针进行加减运算，除非你进行强制类型转换。
3. **指针算术的内存偏移是类型依赖的**：在进行指针加法和减法时，操作的步长是由指针类型的大小决定的。比如，`int*` 类型指针增加 1 时，它会跳过 4 字节（假设 `sizeof(int)` 为 4），而 `char*` 类型指针增加 1 时，它会跳过 1 字节。
4. **合法范围检查**：虽然指针算术操作是合法的，但它不会自动检查是否越界。例如，`p + 1` 会把指针移动到下一个内存位置，但如果这个位置超出了数组的边界，仍然会导致未定义行为。

