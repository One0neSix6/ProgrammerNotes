---
title: '::运算符'
date: 2025-12-06 14:54:40
categories: 编程语言
tags: C++
---

`::` 在 C++ 里叫 **作用域解析运算符 / 域运算符（scope resolution operator）**，用来告诉编译器：我要用某个作用域里的某个名字。它只在**编译期**起作用，不会产生运行时开销。

## 基本概念

C++ 里名字可以出现在不同作用域：

- 全局作用域（global）
- 命名空间作用域（namespace）
- 类/结构体/枚举的作用域
- 局部作用域（函数内部、块内部）

`::` 的作用就是：**指定从哪个作用域取名字**。

**语法形式：**

- `A::name` —— 在作用域 `A` 里找 `name`
- `::name` —— 在**全局作用域**里找 `name`

------

## 访问全局

当**局部变量/成员变量**和**全局变量**同名时，`::` 可以强制用全局的。

```cpp
int value = 42;  // 全局变量

void func() {
    int value = 10;  // 局部变量，隐藏了全局的 value

    std::cout << value << std::endl;   // 输出 10（局部）
    std::cout << ::value << std::endl; // 输出 42（全局）
}
```

`::value` 就是“从**全局作用域**拿 value”。

同理，用在函数上也是一样：

```cpp
void print() { 
    std::cout << "global\n"; 
}

struct S {
    static void print() { 
        std::cout << "S::print\n"; 
    }

    static void test() {
        print();    // 调用 S::print
        ::print();  // 调用全局的 print
    }
};
```

------

## 命名空间成员

这是最常见的用法之一：**从某个命名空间取名字**。

```cpp
namespace math {
    double pi = 3.14159;
    double sin(double x) { 
        /* ... */ 
        return x; 
    }
}

int main() {
    double x = math::pi;
    double y = math::sin(1.0);
}
```

- `math::pi` 表示命名空间 `math` 中的变量 `pi`
- `std::cout`, `std::vector`, `std::string` 等都是同样的道理

你也可以用 `::std::cout` 明确表示：std 是在**全局作用域里的命名空间**：

```cpp
::std::cout << "hello\n";
```

这在有奇怪宏/变量遮蔽名字时有时会用到。

------

## 类 / 结构体成员

这里要注意两种场景：

### 定义成员函数

```cpp
class Person {
public:
    void speak();
    static int count;
};

// 类外定义成员函数
void Person::speak() {
    std::cout << "Hi\n";
}

// 类外定义静态成员
int Person::count = 0;
```

- `Person::speak` 表示：作用域在类 `Person` 中的成员函数 `speak`
- `Person::count` 表示：类 `Person` 中的静态成员 `count` 的定义

> 成员函数在类内只声明，在类外定义时，**必须**用 `ClassName::` 告诉编译器“这个函数是哪个类的成员”。

### 调用 / 使用静态成员

**静态成员**可以通过类名加 `::` 调用：

```cpp
Person::count = 5;
Person::speak();       // 如果 speak 是 static 的话
```

非静态成员**不能**用类名直接调用（缺少对象），必须用对象或指针，通过 `.` 或 `->`：

```cpp
Person p;
p.speak();    // OK
Person::speak(); // 只有在 speak 是 static 时才 OK
```

规则：

- **类外定义/声明成员**：一定用 `Class::member`
- **调用静态成员**：推荐 `Class::static_member()`
- **访问普通成员**：用对象 `.member` 或指针 `->member`

------

## 枚举成员

C++11 引入 **强类型枚举（enum class）**，枚举值必须加 `::` 前缀：

```cpp
enum class Color {
    Red,
    Green,
    Blue
};

Color c = Color::Red;    // 必须 Color::Red

// 旧式枚举（enum）可以不加类型名，但会污染作用域
enum OldColor {
    Red,
    Green,
    Blue
};

OldColor c2 = Red;       // 直接用 Red
OldColor c3 = OldColor::Red; // 也可以用作用域方式
```

总结：

- `enum class`：**必须** `Enum::Value`
- 旧式 `enum`：可以 `Value` 也可以 `Enum::Value`

------

## 嵌套类型 / 嵌套命名空间

类里可以定义嵌套类型，命名空间里可以嵌套命名空间，这时同样用 `::`：

```cpp
namespace A {
    namespace B {
        void foo();
    }
}

void A::B::foo() { }  // 定义嵌套命名空间里的函数
```

C++17 之后可以写成：

```cpp
namespace A::B {
    void foo();  // 这里的 :: 也是作用域运算符的一部分
}
```

嵌套类型：

```cpp
class X {
public:
    class Inner {
    public:
        void test();
    };
};

void X::Inner::test() {
    std::cout << "X::Inner::test\n";
}
```

------

## 构造函数 / 析构函数

构造函数和析构函数在类外定义时同样要用 `::`：

```cpp
class A {
public:
    A();      // 构造
    ~A();     // 析构
};

A::A() {
    // 构造函数定义
}

A::~A() {
    // 析构函数定义
}
```

------

## 模板类的成员定义

在模板外定义成员时也要用 `::` 指明作用域：

```cpp
template <typename T>
class Vector {
public:
    void push_back(const T& x);
};

template <typename T>
void Vector<T>::push_back(const T& x) {
    // ...
}
```

`Vector<T>::push_back` 表示“模板类 `Vector<T>` 的成员函数 `push_back`”。

------

## 指向成员的指针

当获取“**成员指针**”（不是普通函数指针）时，也会看到 `::`：

```cpp
class C {
public:
    int data;
    void func() { std::cout << "func\n"; }
};

int C::* pData = &C::data;         // 数据成员指针
void (C::*pFunc)() = &C::func;     // 成员函数指针

C obj;
obj.*pData = 10;      // 通过成员指针访问
(obj.*pFunc)();       // 调用成员函数
```

这里 `&C::data` / `&C::func` 都是用 `::` 指定“从类 C 的作用域里取这两个成员”。

------

## 查找规则

C++ 的名字查找大致顺序是：**局部 → 类作用域 / 命名空间 → 外层命名空间 → 全局**。

如果你写：

```cpp
int value = 1;

namespace N {
    int value = 2;

    void f() {
        int value = 3;
        std::cout << value << std::endl;      // 3
        std::cout << N::value << std::endl;   // 2
        std::cout << ::value << std::endl;    // 1（全局）
    }
}
```

可以看到：

- `value` → 最近的局部
- `N::value` → 命名空间 N
- `::value` → 全局作用域
