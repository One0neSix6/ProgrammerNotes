---
title: TCP/IP网络编程笔记06
date: 2025-12-09 11:16:10
categories: 网络编程
tags: TCP/IP网络编程
---

# 第六章

## 本章整体定位

书名：**《TCP/IP 网络编程》（尹圣雨）**
 第 6 章标题：**基于 UDP 的服务器端/客户端**

本章在前面 TCP 相关内容的基础上，重点讲：

1. **UDP 套接字的特点**：无连接、数据报（有边界）、不保证可靠，但简单高效 
2. **基于 UDP 的数据 I/O 函数**：`sendto` / `recvfrom` 的用法
3. **UDP 客户端地址分配问题**：什么时候需要 `bind`，什么时候不用管
4. **UDP 的输出特性**：一次发送对应一次接收、数据报边界、不存在“黏包”问题
5. **“已连接”的 UDP 套接字**：给 UDP 调用 `connect` 的含义和用途 
6. 用一个 **UDP 回声（echo）服务器/客户端** 综合演示整个流程

本章整体对标的是：**在已经理解 TCP 的前提下，掌握 UDP 的 API 和行为差异**，为之后更复杂的实时音视频、游戏等场景打基础。

------

## 理解 UDP 套接字

### UDP 的核心特点（再复习）

和 TCP 对比记忆会更清晰：

- **无连接（connectionless）**
    - 不需要 `connect` / 三次握手；
    - 没有“连接状态”，每个数据报里都带有来源/目的端口信息。
- **面向数据报（datagram）**
    - 一次 `sendto` = 发送一个独立的数据报；
    - 一次 `recvfrom` = 接收一个完整的数据报（要么全收，要么截断），**不会拆成多次 recv，也不会和别的报合并**。
- **不保证可靠**
    - 可能丢包、乱序、重复；
    - 协议本身不做重传控制。
- **速度 & 编程复杂度**
    - 协议头更简单，没有拥塞控制 / 滑动窗口等机制，因此**延迟小、开销低**；
    - 编程 API 反而更简单（不用 listen / accept）。

典型应用场景：实时音视频、在线游戏、语音通话等——**能接受少量丢包，但很在意延迟**的业务。

------

## 基于 UDP 的数据 I/O 函数

### sendto/recvfrom

UDP 没有所谓“连接”，所以每次发送时都需要“带上目标地址”，每次接收也需要知道“是谁发来的”。对应函数是：

```c
ssize_t sendto(int sockfd,
               const void* buf, size_t len, int flags,
               const struct sockaddr* dest_addr, socklen_t addrlen);

ssize_t recvfrom(int sockfd,
                 void* buf, size_t len, int flags,
                 struct sockaddr* src_addr, socklen_t *addrlen);
```

- `sendto`：
    - `dest_addr` / `addrlen`：发送目标的 IP + 端口
- `recvfrom`：
    - `src_addr` / `addrlen`：**输出参数**，用来存放“对方的地址信息”

> 和 TCP 不同：
>
> - TCP 客户端和服务端一旦 `connect/accept` 成功，就只在一条“连接”上 `read/write`；
> - UDP 则是每个包都带地址，服务端**通过 `recvfrom` 的 `src_addr` 区分不同客户端**。

------

### UDP 服务器 / 客户端调用顺序

#### UDP 服务器端

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

void error_handling(char* message);

#define BUFF_SIZE 1024

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("port is null\n");
        exit(1);
    }
    int server_sock = socket(PF_INET, SOCK_DGRAM, 0);
    if (server_sock == -1) {
        error_handling("socket() error");
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(atoi(argv[1]));

    if (bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        error_handling("bind() error");
    }

    char message[BUFF_SIZE];
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = 0;
    while (1) {
        client_addr_len = sizeof(client_addr);
        int len = recvfrom(server_sock, message, BUFF_SIZE - 1, 0, (struct sockaddr*)&client_addr, &client_addr_len);
        if (len > 0) {
            message[len] = '\0';
            printf("from clinet, msg: %s", message);
            sendto(server_sock, message, len, 0, (struct sockaddr*)&client_addr, client_addr_len);
        } else {
            break;
        }
    }
    close(server_sock);

    return 0;
}

void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}
```

**注意：**

- 没有 `listen`，没有 `accept`；
- 整个进程只需要一个 `serv_sock`，就能同时和多个客户端通信。

#### UDP 客户端

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

void error_handling(char* message);

#define BUFF_SIZE 1024

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("port is null\n");
        exit(1);
    }
    int client_sock = socket(PF_INET, SOCK_DGRAM, 0);
    if (client_sock == -1) {
        error_handling("socket() error");
    }
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    server_addr.sin_port = htons(atoi(argv[1]));

    char message[BUFF_SIZE];
    struct sockaddr_in from_addr;
    socklen_t from_addr_len = 0;

    // 这里如果使用 connect 连接后，后续可以使用 read/write 读写数据
    connect(client_sock, (struct sockaddr*)&server_addr, sizeof(server_addr));
    while (1) {
        fgets(message, BUFF_SIZE, stdin);
        if (strcmp(message, "q\n") == 0) {
            break;
        }
        int len = sendto(client_sock, message, strlen(message), 0, (struct sockaddr*)&server_addr, sizeof(server_addr));
        if (len > 0) {
            from_addr_len = sizeof(from_addr);
            int len = recvfrom(client_sock, message, BUFF_SIZE, 0, (struct sockaddr*)&from_addr, &from_addr_len);
            message[len] = '\0';
            printf("from server, msg: %s", message);
        }
    }
    close(client_sock);

    return 0;
}

void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}
```

这里客户端通常**不显式 `bind`**，由系统自动分配本地端口。

------

## UDP 客户端的地址分配问题

这一节主要讨论两个问题：

1. **只“服务器端 bind、客户端不 bind”可以吗？**
2. **如果客户端也 bind 会怎样？**

### 谁需要 bind

- **服务器端**：
    - 一般要对外提供固定端口（比如 53 号 DNS、123 号 NTP、你指定的 9190 等）；
    - 所以要用 `bind` 把 socket 绑到一个端口上，客户端才能“按端口号来找你”。
- **客户端**：
    - 通常不需要固定端口，只要能跟服务器互发数据就行；
    - 系统会在第一次 `sendto` 时自动帮你选一个**临时端口（ephemeral port）**，并绑定在该 socket 上。

### 客户端什么时候需要显式 bind

少数情况下也会给 UDP 客户端显式绑定端口，例如：

- 协议要求**用特定的源端口**通信；
- 做调试 / 抓包时，想用固定端口方便过滤；
- P2P / 打洞场景下，需要明确端口映射。

不管是服务器端还是客户端，只要 `bind` 成功，**本地 IP+端口就固定了**。

------

## UDP 的输出特性：数据边界

这是区别 TCP 和 UDP 的一个关键点。

> **TCP：无边界的字节流；
> UDP：有边界的数据报。**

### “有边界”体现在哪些地方

- 每次 `sendto` 发送的是**一整个数据报（datagram）**；
- 每次 `recvfrom` 接收的也是**一整个数据报**：
    - 要么把这一报完整读出（如果缓冲足够大）；
    - 要么缓冲不够时，只取前面一部分，剩下的**被丢弃**，不会在下次 `recvfrom` 里继续补上。
- 所以：
    - **发送次数 = 接收次数**（只要没丢包 / 没截断）；
    - 不存在 TCP 那种“黏包 / 半包”的问题——不会把两次发送粘在一起读，也不会拆成多个 `recv` 才凑齐一报文。

### buffer 太小会怎样

```c
char buf[8];
int len = recvfrom(sock, buf, sizeof(buf), 0, ...);
```

如果对端 `sendto` 发送了 50 字节：

- 你最多能收到 8 字节；
- 其余 42 字节在这一报文里**被直接丢弃**；
- 下次 `recvfrom` 读到的是**下一报**，而不是这一报的剩余部分。

所以在设计协议和 buffer 时，要注意**最大报文长度**，否则会出现“截断”的情况。

------

## 将未连接的 UDP 套接字变为“已连接”

虽然 UDP 是“无连接协议”，但在编程接口层面，可以对 UDP 套接字调用 `connect`，把它变成“已连接的 UDP 套接字”。

### connect 对 UDP 的意义

```c
connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
```

和 TCP 不同：

- 对 UDP 调用 `connect` **不会发起三次握手**，也不会和对端建立“连接状态”；
- 它只是告诉内核：**这个 UDP 套接字默认只和这一个 IP+端口 收发数据**。

效果有几条：

1. 之后可以直接用 `send` / `write` / `recv` / `read`：
    - 不用再传 `dest_addr`、`src_addr`；
    - 代码会更像 TCP 写法。
2. 内核会帮你 **过滤来自其他地址的数据报**：
    - 只把来自 `connect` 指定地址的数据交给这个 socket；
    - 某种程度上可以认为是“只接受这一个对端”。
3. 有些实现中，当对端不可达时，ICMP 错误可以转化为 socket 错误（比如 `ECONNREFUSED`），方便检测。

### 什么时候适合用“已连接 UDP”

- 逻辑上“就是一个客户端 ↔ 一个服务器”的模式；
- 希望代码风格和 TCP 更接近（用 `send/recv`）；
- 不需要同时和多台服务器来回切换。

如果要用同一个 UDP socket 和**多个不同主机**通信，通常就**不要 `connect`**，而是每次 `sendto/recvfrom` 指定地址。

------

## 本章知识点小结

1. **UDP 套接字特点**
    - 无连接、面向数据报、不保证可靠；
    - 适合小数据量、高频、对实时性敏感的场景（语音、视频、游戏等）。
2. **UDP 服务器 / 客户端流程**
    - 服务器：`socket → bind → (循环) recvfrom/sendto → close`
    - 客户端：`socket → (可选 bind) → sendto/recvfrom → close`
    - 没有 `listen`，没有 `accept`，一个 socket 可以服务多个客户端。
3. **基于 UDP 的 I/O 函数**
    - `sendto`：发送数据 + 指定对方地址；
    - `recvfrom`：接收数据 + 得到对方地址。
4. **UDP 的数据边界**
    - 每次 `sendto` 对应每次 `recvfrom`（如果不丢包且 buffer 足够）；
    - buffer 小则报文被截断，剩余部分丢弃；
    - 不存在 TCP 那种“黏包 / 拆包”问题。
5. **地址分配**
    - 服务器一般 `bind` 固定端口；
    - 客户端通常不 `bind`，由系统自动分配临时端口（需要固定时可显式绑定）。
6. **已连接 UDP**
    - 对 UDP 调用 `connect` 不会建立真正“连接”，只是固定一个对端；
    - 可以使用 `send/recv`/`write/read`，并自动过滤其他来源的数据报。

------

## 代码

### udp_server.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define BUFF_SIZE 1024

void error_handling(const char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("Usage: %s <port>\n", argv[0]);
        exit(1);
    }

    int serv_sock = socket(PF_INET, SOCK_DGRAM, 0);
    if (serv_sock == -1) {
        error_handling("socket() error");
    }

    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family      = AF_INET;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_addr.sin_port        = htons(atoi(argv[1]));   // 注意：htons

    if (bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {
        error_handling("bind() error");
    }

    char message[BUFF_SIZE];
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_len;

    while (1) {
        clnt_addr_len = sizeof(clnt_addr);
        int len = recvfrom(serv_sock, message, BUFF_SIZE, 0,
                           (struct sockaddr*)&clnt_addr, &clnt_addr_len);
        if (len < 0) {
            error_handling("recvfrom() error");
        }

        // 补字符串结束符，仅为了打印方便（如果是二进制数据就不要这样做）
        if (len < BUFF_SIZE) {
            message[len] = '\0';
        } else {
            message[BUFF_SIZE - 1] = '\0';
        }

        printf("From client [%s:%d], msg: %s",
               inet_ntoa(clnt_addr.sin_addr),
               ntohs(clnt_addr.sin_port),
               message);

        // 回声发回去
        sendto(serv_sock, message, len, 0,
               (struct sockaddr*)&clnt_addr, clnt_addr_len);
    }

    close(serv_sock);
    return 0;
}
```

### udp_client.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define BUFF_SIZE 1024

void error_handling(const char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("Usage: %s <port>\n", argv[0]);
        exit(1);
    }

    int sock = socket(PF_INET, SOCK_DGRAM, 0);
    if (sock == -1) {
        error_handling("socket() error");
    }

    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family      = AF_INET;
    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    serv_addr.sin_port        = htons(atoi(argv[1]));   // 注意：htons

    char message[BUFF_SIZE];
    struct sockaddr_in from_addr;
    socklen_t from_addr_len;

    while (1) {
        fputs("Input message (Q to quit): ", stdout);
        if (!fgets(message, BUFF_SIZE, stdin)) {
            break;  // EOF
        }

        if (!strcmp(message, "q\n") || !strcmp(message, "Q\n")) {
            break;
        }

        int to_send = (int)strlen(message);
        int sent = sendto(sock, message, to_send, 0,
                          (struct sockaddr*)&serv_addr, sizeof(serv_addr));
        if (sent != to_send) {
            error_handling("sendto() error");
        }

        from_addr_len = sizeof(from_addr);
        int len = recvfrom(sock, message, BUFF_SIZE, 0,
                           (struct sockaddr*)&from_addr, &from_addr_len);
        if (len < 0) {
            error_handling("recvfrom() error");
        }

        if (len < BUFF_SIZE) {
            message[len] = '\0';
        } else {
            message[BUFF_SIZE - 1] = '\0';
        }

        printf("Message from server: %s", message);
    }

    close(sock);
    return 0;
}
```

