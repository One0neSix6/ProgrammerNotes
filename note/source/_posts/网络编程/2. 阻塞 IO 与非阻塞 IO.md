---
title: 阻塞 IO 与非阻塞 IO
date: 2025-12-06 20:35:58
categories: 网络编程
tags: 套接字
---

## 阻塞 I/O（blocking I/O）

> 调用一个 I/O 函数，如果当前“条件不满足”，**线程就停在那里等**，直到条件满足或出错才返回。

典型场景：

- `accept()`：没有新连接时，就一直卡着等客户端来。
- `recv()`：接收缓冲区里暂时没数据，就一直等数据到来。
- `connect()`：连不上、超时前都卡着。

特点：

- 写代码简单，流程像同步的伪代码：

    ```cpp
    int n = recv(fd, buf, sizeof(buf), 0); // 没数据就一直等
    ```

- 但线程是“睡死”的，在等待期间干不了别的事。

**默认创建的 socket 就是阻塞模式。**

------

## 非阻塞 I/O（non-blocking I/O）

> 调用 I/O 函数时，如果当前“条件不满足”，**立刻返回错误，不等**。

例如把 socket 设为非阻塞之后：

- `accept()`：连接队列为空时，直接返回 -1，`errno = EAGAIN` / `EWOULDBLOCK`
- `recv()`：没有数据，同样返回 -1，`errno = EAGAIN`
- `send()`：发送缓冲区满，也返回 -1，`errno = EAGAIN`
- `connect()`：会返回 -1，`errno = EINPROGRESS`，表示“正在连接中”

特点：

- 函数调用不会“卡死”，线程可以继续干别的。
- 但是必须：
    - 要么不停轮询（很蠢）
    - 要么配合 `select/poll/epoll` 这类 I/O 多路复用，等内核告诉你“这个 fd 读/写就绪了”再去 `recv/send`。

------

## 在刚才的 TcpServer / TcpClient 里，哪里会阻塞

### TcpServer

大致是这样的结构：

```cpp
bool TcpServer::start() {
    m_sockfd = ::socket(...);
    ::bind(m_sockfd, ...);
    ::listen(m_sockfd, 1024);
}

void TcpServer::run() {
    while (running_) {
        int connfd = ::accept(m_sockfd, nullptr, nullptr);  // ①
        handleClient(connfd);                                // ②
    }
}

void TcpServer::handleClient(int connfd) {
    char buf[1024]{};
    ssize_t len = ::recv(connfd, buf, sizeof(buf) - 1, 0);   // ③
    ::send(connfd, buf, len, 0);                             // ④(可能)
    ::close(connfd);
}
```

**可能阻塞的地方：**

1. `accept()`
    - 当没有新客户端连接时，会一直阻塞在这里。
2. `recv()`
    - 客户端暂时没有发数据，接收缓冲区为空，就会阻塞等数据。
3. `send()`
    - 一般情况下很快返回；
    - **但**在极端情况（对端不收、网络拥塞、发送缓冲区满）会阻塞。

> `socket / bind / listen` 一般不会阻塞，它们是“瞬间完成”的配置动作。

------

### TcpClient

大致是：

```cpp
bool TcpClient::connectToServer() {
    sockfd_ = ::socket(...);
    ::connect(sockfd_, ...);                // ①
}

bool TcpClient::sendData(const std::string& data) {
    ::send(sockfd_, data.c_str(), data.size(), 0); // ②(可能)
}

bool TcpClient::recvData(std::string& out) {
    ::recv(sockfd_, buf, sizeof(buf) - 1, 0);      // ③
}
```

**可能阻塞的地方：**

1. `connect()`
    - 要和服务器完成三次握手，连不通、超时前都可能阻塞一段时间。
2. `send()`
    - 同服务器一样，大部分时间不明显阻塞，但在发送缓冲区写满时会卡住。
3. `recv()`
    - 没有收到服务器数据时，会阻塞等待。

------

## 如何把 socket 设为“非阻塞”？

在 Linux / Cygwin 这类 POSIX 环境下一般用 `fcntl`：

```cpp
#include <fcntl.h>

bool setNonBlocking(int fd) {
    int flags = ::fcntl(fd, F_GETFL, 0);
    if (flags == -1) return false;
    if (::fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) return false;
    return true;
}
```

### 在 TcpServer 里用

- 如果想 **监听 socket 非阻塞**（`accept` 不阻塞）：

```cpp
bool TcpServer::start() {
    m_sockfd = ::socket(...);

    setNonBlocking(m_sockfd);  // 设置成非阻塞

    ::bind(m_sockfd, ...);
    ::listen(m_sockfd, 1024);
}
```

- 如果想 **每个连接也是非阻塞**，在 `accept` 后对 `connfd` 调用：

```cpp
int connfd = ::accept(m_sockfd, nullptr, nullptr);
setNonBlocking(connfd);
handleClient(connfd);
```

此时：

- `accept` 在没有连接时返回 `-1, errno=EAGAIN`
- `recv` 在没数据时返回 `-1, errno=EAGAIN`
- `send` 在缓冲区满时返回 `-1, errno=EAGAIN`

你就要在代码里判断这些情况，通常配合 `select/poll/epoll` 来等可读/可写，不然 while 死循环会把 CPU 打满。

### 在 TcpClient 里用

- 如果只是想“连接完成后非阻塞”，可以：

```cpp
sockfd_ = ::socket(...);
::connect(sockfd_, ...);       // 还是阻塞式 connect
setNonBlocking(sockfd_);       // 之后收发变成非阻塞
```

- 如果连 `connect` 也想非阻塞，通常做法：

```cpp
sockfd_ = ::socket(...);
setNonBlocking(sockfd_);

int ret = ::connect(sockfd_, ...);
if (ret < 0 && errno == EINPROGRESS) {
    // 连接正在进行中，以后用 select/poll 等待可写来判断是否连上
}
```

这就进入“异步连接”的套路了，配合 `select` / `epoll` 才好用。

------

## 缓冲区

每个 TCP socket 在内核里都有两块重要的缓冲区：

- **发送缓冲区（send buffer）**
    - 存放通过 `send()` / `write()` 写进去、但还没真正发送完或还没被对端确认的数据。
    - 对于阻塞 socket：只要还有空间，`send()` 一般会立刻把数据拷进这个缓冲区，然后返回；真正往网卡发、重传这些由内核慢慢搞。
    - 如果缓冲区满：
        - 阻塞 socket：`send()` 会卡着等空间（可能阻塞）。
        - 非阻塞 socket：`send()` 直接返回 `-1, errno=EAGAIN`。
- **接收缓冲区（recv buffer）**
    - 内核把从网卡收到的 TCP 数据包重组好之后，先存到这里。
    - 当调用 `recv()` 时，数据是从这个缓冲区里拷贝到你的用户空间 `buf`。
    - 对于阻塞 socket：
        - 如果缓冲区里有数据，`recv()` 立即返回；
        - 如果为空，就阻塞等待。
    - 对于非阻塞 socket：
        - 缓冲区为空时，直接 `-1, errno=EAGAIN`。

可以简单理解为：**应用层和内核之间有一对“队列”，发送队列和接收队列**。

------

### 如何修改它们的大小

通过 `setsockopt` / `getsockopt`：

```cpp
#include <sys/socket.h>

// 设置发送缓冲区大小
int snd_size = 1 * 1024 * 1024; // 1MB
::setsockopt(fd, SOL_SOCKET, SO_SNDBUF,
             &snd_size, sizeof(snd_size));

// 设置接收缓冲区大小
int rcv_size = 1 * 1024 * 1024; // 1MB
::setsockopt(fd, SOL_SOCKET, SO_RCVBUF,
             &rcv_size, sizeof(rcv_size));
```

注意：

- 一般建议在 `connect` / `listen` 之前设置（有些系统之后改不一定完全生效）。

- `getsockopt` 可以查看当前值：

    ```cpp
    int actual = 0;
    socklen_t len = sizeof(actual);
    ::getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &actual, &len);
    ```

- 有的系统会把你设置的值乘以 2（因为内部还有 bookkeeping），看到的会比你设的大一点，这是正常的。

------

## keep-alive

这里说的通常是 **TCP keepalive 机制**（不要和 HTTP 的 Keep-Alive 混了）：

场景：两端建立了 TCP 连接，但长时间不收不发：

- 物理线路可能断了；
- 中间 NAT / 防火墙可能把连接给丢了；
- 对端进程可能崩溃了。

如果没有任何数据，“正常 TCP”是**感知不到**的，内核会一直认为连接是“活着”的。

**开启 TCP keepalive 后：**

- 当一个连接空闲了“足够久”的时间（Linux 默认约 2 小时），内核会周期性地发一些探测包（keepalive probe）。
- 如果对端正常：
    - 会回 ACK，连接继续保持。
- 如果对端已经不可达：
    - 多次探测都失败后，内核认为连接挂了，`recv` 之类的会返回错误。

### 如何开启

对一个 socket 调用 `setsockopt`：

```cpp
int opt = 1;
::setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE,
             &opt, sizeof(opt));
```

你可以在：

- 服务器：`accept` 得到 `connfd` 后，对 `connfd` 开启；
- 客户端：`socket` 之后，对 `sockfd` 开启。

在 Linux 上还可以进一步调节细节（可选）：

```cpp
int idle = 60;     // 空闲多久开始探测，默认 7200 秒
int interval = 10; // 探测间隔，默认 75 秒
int count = 5;     // 失败几次认为死

::setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE,  &idle,     sizeof(idle));
::setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &interval, sizeof(interval));
::setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT,   &count,    sizeof(count));
```

> 仍然要注意：
>
> - keepalive 的时间粒度比较粗（秒级甚至小时级）
> - 很多业务还是会在**应用层**自己做心跳（比如每 10 秒发一次 ping）。

