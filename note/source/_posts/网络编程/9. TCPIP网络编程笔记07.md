---
title: TCP/IP网络编程笔记07
date: 2025-12-09 15:27:10
categories: 网络编程
tags: TCP/IP网络编程
---

# 第七章：优雅地断开套接字连接

## 第七章整体定位

书名：**《TCP/IP 网络编程》（尹圣雨）**
第 7 章标题：**优雅地断开套接字连接**

本章解决的问题是：

1. `close`/`closesocket` 这种“直接关连接”有什么隐患？
2. 什么是 **单方面断开连接**，会带来什么问题？
3. 什么是 **半关闭（half-close）**，如何用 `shutdown` 实现？
4. Linux & Windows 下“优雅关闭”的写法差异。

核心思想一句话：

> **TCP 是双向“流”，很多时候我们想先关闭“发送方向”，但继续接收对方剩余数据，这就需要“半关闭”。**

------

## 单方面断开连接的问题（直接 close）

在前几章我们用的都是这种写法：

```c
// 通信结束
close(sock);          // Linux
// 或 closesocket(sock);  // Windows
```

这在很多简单 demo 里没问题，但书里提醒了一个隐患：

> **`close` / `closesocket` 是“单方面断开连接”的方法：**
>  调用后本端既不发也不收，连接直接结束。
>  如果对端那边还没发完数据，或还准备要发数据，就可能出事。

典型问题：

1. **对端还没发完数据，你就直接 close：**
    - 你不会再 `read`，对端后续发来的数据会被丢弃；
    - 对端在 `send` 时可能收到 RST 或错误，认为“对方强制断开”。
2. **你还没把要发的数据告诉对方已经“发完”**
    - 对端不知道你什么时候结束，只能靠约定（比如“读到 0 说明结束”）；
    - 如果你没给出“结束信号”，对端 `read` 可能一直阻塞。

所以书里的观点是：

> 在 TCP 里，**粗暴地直接关连接** 可能会让对端“懵逼”，甚至导致数据丢失或异常，需要更“优雅”的做法。

------

## 半关闭（half-close）

###  半关闭是什么

- **TCP 连接是全双工的**：
     一条连接上有“发送方向”和“接收方向”两条数据流。
- **半关闭** = 只关闭其中一个方向：
    - 常见是“关闭发送，但保留接收”：
        - 我不再给你发数据；
        - 但我还会继续收你剩下要发的东西。

在 TCP 报文级别上：

- 关闭“发送方向”就是发送 **FIN**，告诉对方“我这边发完了”；
- 但仍然可以继续接收对方发来的数据，直到对方也发送 FIN。

### shutdown 函数

Linux 上的原型（Windows 类似）：

```c
#include <sys/socket.h>

int shutdown(int sockfd, int how);
```

- `how` 取值：
    - `SHUT_RD`：关闭**接收方向**（不再收，读会返回 EOF）；
    - `SHUT_WR`：关闭**发送方向**（不再发，会给对方发送 FIN）；
    - `SHUT_RDWR`：等价于 `SHUT_RD | SHUT_WR`，两边都关。

**常用场景：**

> 我这边已经把要发的数据全部 send 完了，
>  想告诉对面“我发完了，你可以开始处理/回应”，但我还要继续接收它的回复。

就可以：

```c
// 发送完所有数据后：
shutdown(sock, SHUT_WR);   // 半关闭发送方向

// 然后继续 read，直到对端也发完（read 返回 0）
while ((len = read(sock, buf, sizeof(buf))) > 0) {
    // 处理对端回来的数据
}
close(sock);               // 最后再彻底关闭
```

**效果：**

- 对端在 `read` 时，会在读完你所有数据后得到 EOF（返回 0），知道“你发完了”；
- 你还能继续 `read` 它往回发的结果；
- 整个过程是“双方都把自己的话说完，再礼貌道别”的感觉。

这就是本章标题里的“**优雅地断开套接字连接**”。

------

## Linux / Windows 上的差异

本章还顺带说明了 Windows 上同样有 `shutdown`：

- Windows：

    ```c
    #include <winsock2.h>
    int shutdown(SOCKET s, int how);
    ```

- `how` 参数用 `SD_RECEIVE` / `SD_SEND` / `SD_BOTH`，含义和 Linux 类似。

- 最后仍然要 `closesocket(s);` 释放资源。

本质上：**跨平台的“优雅关闭”思路是一样的，只是函数名/常量名略有不同。**

------

## 代码

demo_shutdown_server.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>

#define BUFF_SIZE 1024

void error_handling(char* message);

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("port is null\n");
        exit(1);
    }
    int server_sock, client_sock;
    char buf[BUFF_SIZE];
    int read_cnt;

    struct sockaddr_in server_addr, client_addr;
    socklen_t client_addr_len;

    FILE* fp = fopen("data.txt", "rb");
    if (fp == NULL) {
        error_handling("fopen() error");
    }
    server_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (server_sock < 0) {
        error_handling("socket() error");
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(atoi(argv[1]));

    if (bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        error_handling("bind() error");
    }

    if (listen(server_sock, 5) < 0) {
        error_handling("listen() error");
    }

    client_addr_len = sizeof(client_addr);
    client_sock = accept(server_sock, (struct sockaddr*)&client_addr, &client_addr_len);
    if (client_sock < 0) {
        error_handling("accept() error");
    }

    while (1) {
        read_cnt = fread((void*)buf, 1, BUFF_SIZE, fp);
        if (read_cnt < BUFF_SIZE) {
            write(client_sock, buf, read_cnt);
            break;
        }
        write(client_sock, buf, BUFF_SIZE);
    }
    shutdown(client_sock, SHUT_WR);

    int len = read(client_sock, buf, BUFF_SIZE - 1);
    if (len > 0) {
        buf[len] = '\0';
        printf("message from client, msg: %s\n", buf);
    }

    close(client_sock);
    close(server_sock);
    fclose(fp);

    return 0;
}

void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}

```

demo_shutdown_client.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/socket.h>
#include <unistd.h>
#include <arpa/inet.h>

#define BUFF_SIZE 1024

void error_handling(char* message);

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("port is null\n");
        exit(1);
    }

    int client_sock;
    FILE* fp;
    fp = fopen("data2.txt", "wb");
    if (fp == NULL) {
        error_handling("fopen() error");
    }
    client_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (client_sock < 0) {
        error_handling("socket() error");
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    server_addr.sin_port = htons(atoi(argv[1]));

    if (connect(client_sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        error_handling("connect() error");
    }

    char buf[BUFF_SIZE];
    int read_cnt = 0;
    while ((read_cnt = read(client_sock, buf, BUFF_SIZE)) > 0) {
        fwrite((void*)buf, 1, read_cnt, fp);
    }
    const char* msg = "hello";
    write(client_sock, msg, strlen(msg));

    fclose(fp);
    close(client_sock);

    return 0;
}


void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}

```

## 第七章知识点小结

1. `close`/`closesocket` 是“单方面断开连接”，简单粗暴，在对端还未发送完数据时可能引发问题。
2. TCP 是全双工的，两端都有“发送流”和“接收流”，可以只关闭其中一条——这就是 **半关闭**。
3. 使用 `shutdown(sock, SHUT_WR)` 可以**只关闭发送方向**，向对端发送 FIN；此后本端不能再发数据，但还能继续收。
4. 适合的场景：比如“客户端把文件发给服务器后，还需要接收服务器的处理结果”；发送完文件就半关闭发送，接着 `read` 到 EOF 为止。
5. Windows 平台也提供 `shutdown`，用法与 Linux 类似，只是常量名略不同。

------

# 第八章：域名及网络地址

## 第八章整体定位

书名：**《TCP/IP 网络编程》（尹圣雨）**
 第 8 章标题：**域名及网络地址**

本章主要内容：

1. 解释 **域名（Domain Name）** 和 **IP 地址** 的关系
2. 简单介绍 **DNS（域名系统）** 的作用
3. 讲解几个“**域名 ↔ IP**”之间转换的函数：
    - 经典的 `gethostbyname` / `gethostbyaddr`（IPv4）
    - 以及更通用的 `getaddrinfo` / `getnameinfo` 接口（适配 IPv6）
4. 如何用这些函数实现“输入域名 → 解析出 IP → 建立连接”。

本章整体比较偏应用，不涉及太多协议细节。

------

## 域名系统与 IP 地址

### 为什么要有域名？

- IP 地址是机器能懂的“数字地址（IPv4: 32 位整数）”；
- 域名是人能读的“文字地址”，比如：
    - `142.250.68.132` ↔ `www.google.com`
    - `39.156.66.10` ↔ `www.baidu.com`

> **DNS（Domain Name System）** 就是完成“域名 ↔ IP 地址”转换的分布式系统。

在编程层面，你通常不会直接写 DNS 协议，而是通过标准库函数完成解析。

------

### 域名解析流程

以访问 `www.example.com` 为例：

1. 应用（如浏览器 / 你的程序）调用解析函数，比如 `gethostbyname("www.example.com")`；
2. 系统先查本地缓存 / `hosts` 文件；
3. 若没有，再问本地 DNS 服务器；
4. DNS 服务器递归 / 迭代向根 / 顶级域名 / 权威服务器查，最终得到一个或多个 IP；
5. 解析结果返回给你的程序，你再拿这些 IP 去 `connect`。

在我们这本书的级别，只需要记住：

> **程序 → 标准库函数（gethostbyname/getaddrinfo） → 操作系统 / DNS → 返回 IP 列表。**

------

## 域名到 IP 的转换（IPv4）

这一节主要围绕一个经典接口：`gethostbyname`。

> 注意：在现代代码里更推荐用 `getaddrinfo`，但书里重点讲的是 `gethostbyname` 这一套。

`gethostbyname` 返回 `struct hostent*`，结构大致是：

```c
struct hostent {
    char*  h_name;       // 官方主机名
    char** h_aliases;    // 别名列表（以 NULL 结尾）
    int    h_addrtype;   // 地址类型：AF_INET 等
    int    h_length;     // 地址长度（IPv4 为 4）
    char** h_addr_list;  // IP 地址列表（以 NULL 结尾）
};
```

常用的是 `h_addr_list`，它是一个“IP 地址数组”，每个元素都是 `struct in_addr*` 对应的二进制地址。

### 示例

```c
#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <netdb.h>      // gethostbyname, hostent

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("Usage: %s <hostname>\n", argv[0]);
        exit(1);
    }

    const char* hostname = argv[1];

    struct hostent* host = gethostbyname(hostname);
    if (!host) {
        herror("gethostbyname");   // 打印错误信息
        exit(1);
    }

    printf("Official name: %s\n", host->h_name);

    // 打印所有别名
    char** alias = host->h_aliases;
    while (*alias) {
        printf("Alias: %s\n", *alias);
        alias++;
    }

    // 打印所有 IP 地址
    char** addr_ptr = host->h_addr_list;
    while (*addr_ptr) {
        struct in_addr addr;
        addr.s_addr = *(uint32_t*)(*addr_ptr);    // 取出二进制 IP

        printf("IP: %s\n", inet_ntoa(addr));
        addr_ptr++;
    }

    return 0;
}
```

运行示例：

```bash
./dns_lookup www.baidu.com
```

程序内部流程：

1. 调用 `gethostbyname("www.baidu.com")`；
2. 得到一个 `hostent`，里面有多个 IP；
3. 使用 `inet_ntoa` 把二进制 IP 转成字符串形式打印。

> **小结：**
>
> - `gethostbyname`：域名 → `hostent` → `h_addr_list` → IP 列表
> - `inet_ntoa`：二进制 IPv4 地址 → 点分十进制字符串

------

## 反向解析

与 `gethostbyname` 相反，如果你有一个 IP，想知道对应的主机名（有时用于日志等），可以用：

```c
struct hostent* gethostbyaddr(const void* addr, socklen_t len, int type);
```

- `addr`：指向二进制格式的 IP，例如 `struct in_addr` 的地址；
- `len`：地址长度（IPv4 为 4）；
- `type`：地址类型（`AF_INET`）。

返回的仍然是 `struct hostent*`，可以取 `h_name` 作为“官方主机名”。

> 真实环境中，这依赖 DNS 服务器是否配置了反向解析记录（PTR），不一定都能查到。

------

## 更现代的接口

虽然书中主要讲了 `gethostbyname`，但现代网络编程更推荐：

- `getaddrinfo`：替代 `gethostbyname` + `getservbyname`，同时支持 IPv4 / IPv6；
- `getnameinfo`：替代 `gethostbyaddr` + `getservbyport`。

简单说下 `getaddrinfo` 的基本用法（印象里书后面也会提到）：

```c
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

int getaddrinfo(const char* node, const char* service,
                const struct addrinfo* hints,
                struct addrinfo** res);
void freeaddrinfo(struct addrinfo* res);
```

使用方式：

1. 填好 `hints` 结构（比如要 IPv4 还是 IPv6、TCP 还是 UDP）；
2. 调 `getaddrinfo("www.example.com", "80", &hints, &res)`；
3. 遍历 `res` 链表，里面每个 `addrinfo` 都包含一个可用于 `connect` 的 `sockaddr`；
4. 用完后 `freeaddrinfo(res)`。

**优点：**

- 一套 API 同时支持 IPv4 / IPv6；
- 可以直接得到用于 `socket` / `connect` 的 `sockaddr` 结构；
- 是 POSIX 推荐接口，线程安全。

在以后的 C/C++ 网络项目里，建议优先用 `getaddrinfo`，把 `gethostbyname` 当作“读老代码时看得懂就行”。

------

## 代码

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <netdb.h>
#include <arpa/inet.h>

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("domain name is null\n");
        exit(1);
    }

    struct hostent* host = gethostbyname(argv[1]);
    if (host == NULL) {
        printf("%s is not found\n", argv[1]);
        exit(1);
    }
    printf("official name: %s\n", host->h_name);
    for (int i = 0; host->h_aliases[i]; i++) {
        printf("Aliases %d : %s\n", i, host->h_aliases[i]);
    }
    printf("Address type: %s\n", host->h_addrtype == AF_INET ? "IPV4" : "IPV6");
    for (int i = 0; host->h_addr_list[i]; i++) {
        printf("IP address %d: %s\n", i, inet_ntoa(*(struct in_addr*)host->h_addr_list[i]));
    }

    struct in_addr addr;
    memcpy(&addr, host->h_addr_list[0], host->h_length);
    host = gethostbyaddr((char*)&addr, sizeof(addr), AF_INET);
    if (host == NULL) {
        printf("not found\n");
        exit(1);
    }
    printf("official name: %s\n", host->h_name);
    for (int i = 0; host->h_aliases[i]; i++) {
        printf("Aliases %d : %s\n", i, host->h_aliases[i]);
    }
    printf("Address type: %s\n", host->h_addrtype == AF_INET ? "IPV4" : "IPV6");
    for (int i = 0; host->h_addr_list[i]; i++) {
        printf("IP address %d: %s\n", i, inet_ntoa(*(struct in_addr*)host->h_addr_list[i]));
    }

    return 0;
}
```

## 第八章知识点小结

1. **域名 vs IP：**
    - 域名是给人看的字符串，IP 是机器用的数字地址；
    - DNS 系统负责把域名转换为 IP（正向解析），以及反向解析（IP → 域名）。
2. **经典接口：**
    - `gethostbyname(hostname)`：
         返回 `struct hostent*`，从中读取 `h_addr_list` 得到多个 IP 地址；
    - `gethostbyaddr`：反向解析，IP → 主机名。
3. **辅助转换函数：**
    - `inet_ntoa`：二进制 IPv4 → 文本 `"x.x.x.x"`；
    - （更安全的）`inet_ntop` / `inet_pton` 支持 IPv6。
4. **现代接口：**
    - `getaddrinfo` / `getnameinfo` 更通用、支持 IPv6，线程安全，适合新项目优先使用。