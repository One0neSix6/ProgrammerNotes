---
title: TCP/IP网络编程笔记09
date: 2025-12-10 14:38:10
categories: 网络编程
tags: TCP/IP网络编程
---

# 第十章：多进程服务器端

------

## 第十章整体定位

书名：**《TCP/IP 网络编程》（尹圣雨）**
 第 10 章标题：**多进程服务器端**

本章主要讲解如何使用 **多进程** 来实现并发服务器，重点内容包括进程的创建、信号处理、僵尸进程的处理等。通过多进程模型，服务器可以同时处理多个客户端请求，提高并发处理能力。

------

## 进程介绍

进程是操作系统分配资源的基本单位，它拥有独立的地址空间、数据堆栈和其他辅助数据结构。在 Linux 系统中，每个进程都是独立运行的，其通信通常依赖于进程间通信（IPC）机制。

### 进程的生命周期

- **创建**：通过系统调用 `fork()` 创建新进程。
- **执行**：父进程和子进程在 `fork()` 后都从同一位置开始执行代码。
- **结束**：进程执行完毕后，通过 `exit()` 或 `return` 结束。如果是子进程结束，父进程通过 `wait()` 或 `waitpid()` 等系统调用回收子进程的资源。

### `fork()` 函数

`fork()` 是 Linux 中用于创建进程的系统调用。它会复制当前进程的状态，并返回两次：

- **子进程**：`fork()` 返回值为 0。
- **父进程**：`fork()` 返回值为子进程的进程 ID。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int g_val = 10;
int main(void) {
    int l_val = 20;
    g_val += 5;
    l_val += 10;
    
    int pid = fork();
    if (pid == -1) {
        printf("fork() error, pid = -1\n");
        exit(1);
    } else if (pid == 0) {
        // 子进程执行
        l_val++;
        printf("child process: l_val = %d, g_val = %d\n", l_val, g_val);
    } else {
        // 父进程执行
        g_val++;
        printf("parent process: l_val = %d, g_val = %d\n", l_val, g_val);
    }
    return 0;
}
```

------

## 并发服务器的实现方式

### 多进程服务器

多进程服务器通过 `fork()` 来创建多个进程处理不同的客户端请求。每当父进程接收到一个连接请求时，就创建一个子进程来处理该请求，父进程则继续监听新的连接。

**优点**：

- 进程之间互不干扰，具有较高的稳定性。
- 一个进程的崩溃不会影响其他进程。

**缺点**：

- 创建和销毁进程的开销较大，尤其是在高并发场景中。
- 父进程需要等待子进程结束，以防止僵尸进程的产生。

### 多线程服务器

通过创建多个线程来处理不同的客户端请求。每个线程共享父进程的内存空间，因此比多进程更高效，但也需要注意线程安全和同步问题。

### I/O 多路复用

I/O 多路复用技术（如 `select()`、`poll()`、`epoll()`）允许服务器通过一个进程或线程管理多个客户端连接，避免了为每个客户端创建一个独立进程或线程的开销。适用于大规模并发连接的场景。

------

## 创建进程的方式

在多进程模型中，常用的进程创建方法是 `fork()`。

### `fork()` 函数

`fork()` 函数创建一个新的子进程，子进程是父进程的一个副本。它返回两次：在父进程中返回子进程的 PID，在子进程中返回 0。

#### **原型**：

```c
pid_t fork(void);
```

#### **返回值**：

- **子进程**：返回 0。
- **父进程**：返回子进程的 PID。

### `wait()` 和 `waitpid()` 函数

这两个函数用于父进程等待子进程结束，并回收其资源。

- **`wait()`**：等待任意子进程退出，获取其退出状态。
- **`waitpid()`**：可以指定等待特定的子进程，并控制是否阻塞。

wait.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <sys/wait.h>

int main(void) {
    int pid = fork();
    if (pid == -1) {
        return 1;
    } else if (pid == 0) {
        exit(7);
    } else {
        printf("child process id = %d\n", pid);

        int status;
        wait(&status);

        if (WIFEXITED(status)) {
            printf("child process send value: %d\n", WEXITSTATUS(status));
        }

        sleep(30);
    }

    return 0;
}
```

waitpid.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(void) {
    int pid = fork();
    if (pid == -1) {
        exit(1);
    } else if (pid == 0) {
        sleep(15);
        return 77;
    } else {
        int status;
        while (!waitpid(-1, &status, WNOHANG)) {
            sleep(3);
            puts("sleep 3sec");
        }
        if (WIFEXITED(status)) {
            printf("child process return value: %d\n", WEXITSTATUS(status));
        }
    }
    return 0;
}
```

------

## 信号介绍

信号是进程间的一种通信方式，用于通知进程发生了某种事件。常见的信号包括 `SIGCHLD`（子进程退出）、`SIGTERM`（终止进程）、`SIGINT`（中断进程）等。

### `signal()` 和 `sigaction()` 函数

#### `signal()`：

`signal()` 用于捕获信号并设置信号的处理函数。它的行为较为简单，但不推荐在现代编程中使用，因为它可能无法处理复杂的信号和信号屏蔽。

```c
void (*signal(int sig, void (*handler)(int)))(int);
```

signal.c

```c
#include <stdio.h>

#include <unistd.h>
#include <signal.h>

void timeout(int sig) {
    if (sig == SIGALRM) {
        puts("timeout");
    }
    alarm(2);
}

void keyControlC(int sig) {
    if (sig == SIGINT) {
        puts("control c pressed");
    }
}

int main() {
    signal(SIGALRM, timeout);
    signal(SIGINT, keyControlC);

    alarm(2);

    for (int i = 0; i < 3; i++) {
        puts("wait...");
        sleep(100);
    }

    return 0;
}
```

#### `sigaction()`：

`sigaction()` 提供了更细粒度的信号控制，推荐使用 `sigaction()` 来替代 `signal()`。它允许更精确地控制信号的处理行为。

```c
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

#### `sigaction` 结构体：

```c
struct sigaction {
    void (*sa_handler)(int);        // 信号处理函数
    sigset_t sa_mask;               // 信号屏蔽字
    int sa_flags;                   // 标志
    void (*sa_restorer)(void);      // 仅在旧版本 Linux 中使用
};
```

### `SIGCHLD` 信号

`SIGCHLD` 信号在子进程结束时发送给父进程。可以通过 `sigaction()` 来捕获并处理这个信号，从而避免僵尸进程的产生。

sigaction.c

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#define __USE_POSIX 1
#include <signal.h>
#include <wait.h>

void handle(int sig) {
    if (sig == SIGCHLD) {
        int status;
        int id = waitpid(-1, &status, WNOHANG);
        if (WIFEXITED(status)) {
            printf("remove pid = %d\n", id);
            printf("child return value = %d\n", WEXITSTATUS(status));
        }
    }
}

int main() {

    struct sigaction act;
    act.sa_handler = handle;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    sigaction(SIGCHLD, &act, 0);

    int pid = fork();
    if (pid == -1) {
        exit(1);
    } else if (pid == 0) {
        sleep(5);
        exit(7);
    } else {
        printf("child process id = %d\n", pid);
        sleep(20);
    }

    return 0;
}
```

------

## 僵尸进程介绍

### 僵尸进程的产生

当子进程结束时，它的状态会保留在操作系统中，直到父进程调用 `wait()` 或 `waitpid()` 来回收它。这个已经结束但仍占用系统资源的子进程被称为 **僵尸进程**。

僵尸进程的存在会占用系统的进程号，导致系统无法创建新的进程。

### 解决僵尸进程的方式

- **父进程调用 `wait()` 或 `waitpid()`**：通过 `wait()` 或 `waitpid()` 回收子进程的资源，避免子进程成为僵尸进程。
- **使用 `sigaction()` 捕获 `SIGCHLD` 信号**：通过捕获 `SIGCHLD` 信号并自动回收子进程，避免僵尸进程。

------

## 多进程并发服务器端实现

以下是一个简单的多进程并发服务器端实现。每当父进程接受到一个连接请求时，它会通过 `fork()` 创建一个子进程来处理该请求。

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/wait.h>

#define BUFF_SIZE 30

void error_handling(char* message);

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("port is null\n");
        exit(1);
    }

    int server_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (server_sock == -1) {
        error_handling("socket() error");
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(atoi(argv[1]));

    if (bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        error_handling("bind() error");
    }
    if (listen(server_sock, 5) == -1) {
        error_handling("listen() error");
    }

    int client_sock;
    struct sockaddr_in client_addr;
    socklen_t client_addr_len = sizeof(client_addr);
    char buf[BUFF_SIZE];
    
    while (1) {
        client_sock = accept(server_sock, (struct sockaddr*)&client_addr, &client_addr_len);
        if (client_sock == -1) {
            continue;
        }

        int pid = fork();
        if (pid == -1) {
            close(client_sock);
            continue;
        } else if (pid == 0) {
            close(server_sock);
            int read_cnt;
            while ((read_cnt = read(client_sock, buf, BUFF_SIZE - 1)) > 0) {
                buf[read_cnt] = '\0';
                printf("Message from client: %s\n", buf);
                write(client_sock, buf, read_cnt);
            }
            close(client_sock);
            return 0;
        } else {
            close(client_sock);
        }
    }

    close(server_sock);
    return 0;
}

void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}
```

------

## I/O分离的客户端实现

为了避免阻塞和提高客户端的效率，可以使用 **I/O 分离** 技术。客户端实现中，主线程负责读取数据，子线程负责发送数据。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define BUFF_SIZE 30

void error_handling(char* message);
void read_data(int sock);
void write_data(int sock);

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("port is null\n");
        exit(1);
    }

    int client_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (client_sock == -1) {
        error_handling("socket() error");
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    server_addr.sin_port = htons(atoi(argv[1]));

    if (connect(client_sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        error_handling("connect() error");
    }

    int pid = fork();
    if (pid == -1) {
        close(client_sock);
        exit(1);
    } else if (pid == 0) {
        write_data(client_sock);
    } else {
        read_data(client_sock);
    }

    close(client_sock);
    return 0;
}

void read_data(int sock) {
    int read_cnt;
    char message[BUFF_SIZE];
    while ((read_cnt = read(sock, message, BUFF_SIZE - 1)) >= 0) {
        if (read_cnt == 0) {
            return;
        }
        message[read_cnt] = '\0';
        printf("message from server: %s\n", message);
    }
}

void write_data(int sock) {
    char message[BUFF_SIZE];
    while (1) {
        fgets(message, BUFF_SIZE, stdin);
        if (strcmp(message, "q\n") == 0) {
            shutdown(sock, SHUT_WR);
            return;
        }
        write(sock, message, strlen(message));
    }
}

void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}
```

------

## 总结

1. **多进程服务器**：通过 `fork()` 创建多个子进程处理客户端请求，每个进程独立运行，适用于稳定性要求较高的应用。
2. **进程管理**：使用 `wait()` 和 `waitpid()` 回收子进程资源，避免僵尸进程。
3. **信号处理**：通过 `sigaction()` 捕获和处理 `SIGCHLD` 信号，解决僵尸进程问题。
4. **I/O 分离**：客户端通过多进程或多线程处理 I/O，避免阻塞，提高响应效率。

