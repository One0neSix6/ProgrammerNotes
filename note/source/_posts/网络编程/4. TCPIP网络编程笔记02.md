---
title: TCP/IP网络编程笔记02
date: 2025-12-07 17:32:58
categories: 网络编程
tags: TCP/IP网络编程
---

## 什么是计算机中的「协议」

用一句话概括：

> **协议（Protocol）就是一套双方都遵守的通信规则。**

就像人和人交流需要遵守语言规则（语法、词义、对话顺序），计算机之间在网络上传递数据，也必须遵守一套共同的“规矩”，否则就会“鸡同鸭讲”。

### 协议一般规定哪些内容

一个完整的网络协议通常包含这几类规则：

1. **数据格式**
    - 一条消息要怎么写？
    - 先写什么字段，再写什么字段？
    - 每个字段占多少字节？
    - 例如：协议头中前 2 字节是长度，后 1 字节是类型……
2. **语义（每个字段的含义）**
    - 某个字段 0/1/2 分别代表什么？
    - 某个标志位设为 1 表示“还有后续数据”，设为 0 表示“结束”等等。
3. **状态与流程**
    - 谁先发？谁后发？
    - 需要先握手吗？几次握手？
    - 出错了怎么处理，是否重传？
4. **错误处理和重传机制**
    - 发现包丢了怎么办？
    - 校验失败怎么办？
    - 超时了要不要重发？

只要是“网络上的约定俗成”，就可以认为是协议的一部分。

### 2. 协议的分层（简单理解）

你可以把网络协议想成一层一层叠起来的：

- 应用层：HTTP、FTP、SMTP、DNS……
- 传输层：TCP、UDP
- 网络层：IP（IPv4/IPv6）
- 链路层：以太网、Wi-Fi …

------

## socket 函数详解

在 C 语言中，创建一个套接字一般写成：

```c
int sockfd = socket(int domain, int type, int protocol);
```

### domain（协议族 / 地址族）

`domain` 指定 **使用哪一类地址格式和底层协议族**。

常见取值：

- `PF_INET` / `AF_INET`
    - IPv4 协议族（最常用）
- `PF_INET6` / `AF_INET6`
    - IPv6 协议族
- `PF_UNIX` / `AF_UNIX`
    - 本地进程间通信（Unix 域套接字）

> 说明：在大多数实现中 `PF_INET` 与 `AF_INET` 数值相同，日常代码中经常直接写 `AF_INET`，效果一样。

------

### type（套接字类型）

`type` 指定套接字的通信语义（面向连接？消息还是字节流？）。

常见取值：

- `SOCK_STREAM`
    - 流式套接字，提供 **可靠的、面向连接** 的 **字节流**
    - 在 `PF_INET` 下，默认对应 **TCP**
- `SOCK_DGRAM`
    - 数据报套接字，提供 **无连接、不可靠** 的 **数据报（消息）**
    - 在 `PF_INET` 下，默认对应 **UDP**
- 还有一些较少用的（了解即可）：
    - `SOCK_RAW`：原始套接字，可手工构造 IP 头等，通常需要 root
    - `SOCK_SEQPACKET`：有序、可靠、记录边界的消息序列

------

### protocol（具体协议）

`protocol` 指定在前两个参数约定的大类下，具体选用哪种协议。

常见值（在 `PF_INET` 下）：

- `0`：**让内核自己选择**该 domain + type 下的默认协议

    `PF_INET + SOCK_STREAM + 0` → 默认是 `IPPROTO_TCP` （TCP）

    - `PF_INET + SOCK_DGRAM + 0` → 默认是 `IPPROTO_UDP` （UDP）

- `IPPROTO_TCP`：明确指定 TCP

- `IPPROTO_UDP`：明确指定 UDP

- `IPPROTO_ICMP` 等其它协议（一般较少直接用 socket 操作）

------

## TCP 套接字 vs UDP 套接字

在 `PF_INET` 下：

- `SOCK_STREAM` → **TCP 套接字**
- `SOCK_DGRAM` → **UDP 套接字**

------

### TCP 套接字（SOCK_STREAM）

#### ✅ 特点

1. **面向连接（Connection-oriented）**
    - 通信前需要三次握手 `connect()`
    - 类似打电话：先拨号、对方接听，然后才能讲话
2. **可靠传输**
    - 保证数据不丢、不乱序、不重复
    - 有序到达：对方收到的字节顺序和发送的一样
    - 发送端接收到确认（ACK）才认为对方收到了
3. **流式传输（byte stream）**
    - 不保留消息边界
    - 对方看到的是一个连续的字节流，而不是一条一条“消息”
4. **拥塞控制和流量控制**
    - 根据网络状况自动调节发送速度
    - 防止把对方和网络“冲爆”

#### 📌 常用场景

- Web 服务：HTTP / HTTPS（浏览器访问网站）
- 文件传输：FTP、SFTP、SCP
- 远程登录：SSH
- 绝大多数需要 **可靠传输** 的场景

#### 👍 优点

- 数据可靠、顺序有保证
- 编程简单，应用层不用自己处理重传、乱序等问题
- 适合对数据完整性要求高的应用

#### 👎 缺点

- 有连接建立/释放开销（握手、挥手）
- 头部开销比 UDP 大一些
- 有时延控制、重传等机制，实时性不如 UDP 好（在网络差时尤为明显）

------

### UDP 套接字（SOCK_DGRAM）

#### ✅ 特点

1. **无连接（Connectionless）**
    - 不需要 `connect()`（可以直接 `sendto()`）
    - 就像发短信：直接发，不管对方在不在
2. **不可靠传输**
    - 不保证数据送达
    - 不保证顺序
    - 可能丢包、重复
    - 没有自动重传机制
3. **数据报（Datagram）**
    - 每次发送的是一整个“数据包”，有明确边界
    - 应用层一次发送，对端一次接收（一个 send 对应一个 recv/recvfrom）
4. **支持广播 / 多播**
    - 可以发给广播地址、组播地址，适合一对多通信

#### 📌 常用场景

- 实时语音 / 视频（VoIP、直播）
- 在线游戏
- DNS 查询
- 一些实时监控、心跳检测

这些场景中：

- **速度比“绝对可靠”更重要**
- 丢几个包并不导致“不可接受”的错误（丢一帧视频画面，用户一般感觉不到）

#### 👍 优点

- 没有连接开销，简单直接
- 开销小、延迟低
- 支持广播、多播
- 适合高并发、高实时性需求

#### 👎 缺点

- 不可靠：丢包、乱序、重复都需要应用层自己处理
- 没有拥塞控制，程序乱发容易把网络打爆（现代应用通常在应用层补救）

------

### 总结对比

| 特性           | TCP 套接字（SOCK_STREAM）                 | UDP 套接字（SOCK_DGRAM）                     |
| -------------- | ----------------------------------------- | -------------------------------------------- |
| 是否面向连接   | ✅ 是                                      | ❌ 否                                         |
| 可靠性         | ✅ 可靠，自动重传、顺序保证                | ❌ 不可靠，可能丢包乱序                       |
| 数据形式       | 字节流（无边界）                          | 数据报（有边界）                             |
| 是否有拥塞控制 | ✅ 有                                      | ❌ 无（应用层自己处理）                       |
| 延迟           | 相对较高                                  | 相对较低                                     |
| 适合场景       | Web、文件传输、登录                       | 实时语音视频、游戏、DNS                      |
| API 使用       | `connect / listen / accept / send / recv` | `sendto / recvfrom` 或 `connect + send/recv` |

------

