---
title: 简易 TCP 客户端
date: 2025-12-06 14:34:58
categories: 网络编程
tags: 套接字
---

> [参考教程](https://www.bilibili.com/video/BV1pu411G7P6?spm_id_from=333.788.player.switch&vd_source=8c404c2c8a2f3403260986ddd6884bb5&p=3)

单线程、同步、阻塞式 TCP echo 客户端示例代码：

```cpp
#include <iostream>
#include <cstring>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

int main() {
    // 创建 socket
    int sockfd = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sockfd < 0) {
        printf("create socket error, code: %d, msg: %s\n", errno, strerror(errno));
        return 1;
    }
    printf("create socket success\n");

    // 连接服务端
    std::string ip = "127.0.0.1";
    int port = 8080;

    sockaddr_in sockaddr = {};
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_addr.s_addr = inet_addr(ip.c_str());
    sockaddr.sin_port = htons(port);
    if (::connect(sockfd, reinterpret_cast<struct sockaddr*>(&sockaddr), sizeof(sockaddr)) < 0) {
        printf("connect socket error, code: %d, msg: %s\n", errno, strerror(errno));
        return 1;
    }
    printf("connect socket success\n");

    // 向服务端发送数据
    std::string data = "hello world";
    ::send(sockfd, data.c_str(), data.size(), 0);
    printf("send: %s\n", data.c_str());

    // 接收服务端数据
    char buf[1023]{};
    ::recv(sockfd, buf, sizeof(buf), 0);
    printf("recv: %s\n", buf);

    // 关闭 socket
    ::close(sockfd);

    return 0;
}
```

------

封装成 `class` 版本：

```cpp
// tcpClient.h
#pragma once

#include <iostream>
#include <cstring>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

class TcpClient {
public:
    TcpClient(const std::string& ip, int port);
    ~TcpClient();

    bool connectToServer();
    bool sendData(const std::string& data) const;
    bool recvData(std::string& out) const;

    void close();
private:
    std::string m_ip;
    int m_port;
    int m_sockfd;
};


```

```cpp
// tcpClient.cpp
#include "TcpClient.h"

TcpClient::TcpClient(const std::string& ip, const int port) :
    m_ip(ip), m_port(port), m_sockfd(-1) {}

TcpClient::~TcpClient() {
    close();
}

bool TcpClient::connectToServer() {
    // 创建 socket
    m_sockfd = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (m_sockfd < 0) {
        printf("create socket error, code: %d, msg: %s\n", errno, strerror(errno));
        return false;
    }
    printf("create socket success\n");

    // 连接服务端
    sockaddr_in sockaddr = {};
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_addr.s_addr = inet_addr(m_ip.c_str());
    sockaddr.sin_port = htons(m_port);
    if (::connect(m_sockfd, reinterpret_cast<struct sockaddr*>(&sockaddr), sizeof(sockaddr)) < 0) {
        printf("connect socket error, code: %d, msg: %s\n", errno, strerror(errno));
        close();
        return false;
    }
    printf("connect socket success\n");
    return true;
}

bool TcpClient::sendData(const std::string& data) const {
    // 向服务端发送数据
    if (m_sockfd < 0) {
        return false;
    }
    ssize_t n = ::send(m_sockfd, data.c_str(), data.size(), 0);
    if (n < 0) {
        printf("send error, code: %d, msg: %s\n", errno, std::strerror(errno));
        return false;
    }
    return true;
}

bool TcpClient::recvData(std::string& out) const {
    // 接收服务端数据
    if (m_sockfd < 0) {
        return false;
    }
    char buf[1024]{};
    ssize_t len = ::recv(m_sockfd, buf, sizeof(buf) - 1, 0);
    if (len < 0) {
        printf("recv error, code: %d, msg: %s\n", errno, strerror(errno));
        return false;
    }
    if (len == 0) {
        printf("server closed connection\n");
        return false;
    }
    buf[len] = '\0';
    out.assign(buf);
    printf("recv: %s\n", buf);
    return true;
}

void TcpClient::close() {
    if (m_sockfd != -1) {
        ::close(m_sockfd);
        m_sockfd = -1;
    }
}

```

```cpp
// client.cpp
#include "socket/TcpClient.h"

int main() {
    TcpClient client("127.0.0.1", 8080);
    if (!client.connectToServer()) {
        return 1;
    }

    const std::string data = "hello";
    if (!client.sendData(data)) {
        printf("send to server fail\n");
        return 1;
    }

    std::string recvData;
    if (!client.recvData(recvData)) {
        printf("recv from server fail\n");
    }

    return 0;
}
```

## wireshark 抓包分析

![image-20251206185634545](https://blog-1314964800.cos.ap-beijing.myqcloud.com/blog/image-20251206185634545.png)

## 整体流程

**TCP 客户端**常见步骤：

1. `socket()` —— 创建一个套接字
2. `connect()` —— 主动连接服务器（IP + 端口）
3. 用 `send()` 给服务器发数据
4. 用 `recv()` 收服务器回的数据
5. 用完之后 `close()` 关闭连接

和服务端那条链路的区别在于：

- 服务端：`socket → bind → listen → accept → recv/send → close`
- 客户端：`socket → connect → send/recv → close`

------

## 相关头文件简介

和服务器一样，网络相关的主要是这几个：

```cpp
#include <sys/socket.h>   // socket, connect, send, recv 等
#include <netinet/in.h>   // sockaddr_in, AF_INET, htons 等
#include <arpa/inet.h>    // inet_addr, inet_pton 等
#include <unistd.h>       // close
```

------

## 创建套接字

```cpp
int sockfd = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
```

和服务器完全一致：

- `AF_INET`：使用 IPv4
- `SOCK_STREAM`：字节流，TCP
- `IPPROTO_TCP`：明确指定 TCP 协议（写 0 也行）

返回值：

- `>= 0`：文件描述符（fd），后续所有操作都用它
- `< 0`：失败，查看 `errno` 和 `strerror(errno)`

------

## sockaddr_in —— 指定要连接的服务端地址

```cpp
std::string ip = "127.0.0.1";
int port = 8080;

sockaddr_in sockaddr = {};
sockaddr.sin_family = AF_INET;
sockaddr.sin_addr.s_addr = ::inet_addr(ip.c_str());
sockaddr.sin_port = ::htons(port);
```

客户端和服务器都用 `sockaddr_in` 描述 IPv4 地址，字段含义一样：

- `sin_family = AF_INET`：地址族 IPv4
- `sin_addr.s_addr = inet_addr("127.0.0.1")`：把字符串 IP 转成 32 位整数（网络字节序）
- `sin_port = htons(port)`：主机字节序 → 网络字节序（大端）

客户端的区别在于：**这是“我要去连谁”的地址**，而服务端那边是“我自己绑定在哪个地址”。

------

## connect() —— 主动连接服务器

```cpp
if (::connect(sockfd,
              reinterpret_cast<struct sockaddr*>(&sockaddr),
              sizeof(sockaddr)) < 0) {
    printf("connect socket error, code: %d, msg: %s\n", errno, strerror(errno));
    ::close(sockfd);
    return 1;
}
printf("connect socket success\n");
```

### 原型

```c
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

### 做了什么？

客户端发起 TCP 三次握手，去连接服务器：

- `sockfd`：刚创建的 socket
- `addr`：目标服务器地址（IP + 端口）
- 成功：返回 0，此时 TCP 连接已建立，可以 `send/recv`
- 失败：返回 -1，常见错误：
    - `ECONNREFUSED`：对方端口没人监听（服务器没起来 / 端口错）
    - `ETIMEDOUT`：连接超时（网络不通、防火墙拦截等）
    - `EHOSTUNREACH` / `ENETUNREACH`：主机或网络不可达

### 和服务器的关系

- 服务端在 `listen()` 后在 `accept()` 处阻塞；
- 客户端调用 `connect()`；
- 内核帮你们完成三次握手：
    - 客户端：`connect` 阻塞等待握手完成
    - 服务端：`accept` 阻塞等待新连接到达
- 成功后：
    - 客户端这边 `connect()` 返回 0
    - 服务端那边 `accept()` 返回一个新的 `connfd`

------

## send() —— 向服务端发送数据

```cpp
std::string data = "hello world";
::send(sockfd, data.c_str(), data.size(), 0);
```

### 原型

```c
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
```

- `sockfd`：已经通过 `connect()` 建立好连接的 socket
- `buf` / `len`：要发送的数据缓冲区和大小
- `flags`：一般写 0

返回值（这里你没有检查）：

- `> 0`：实际发送的字节数（可能小于 `len`，严格写法要循环发送）
- `< 0`：发送出错，查看 `errno`

在 **echo 模式** 下：

- 客户端：`send("hello world")`
- 服务器：`recv` 到 `"hello world"`，然后原样 `send` 回来

------

## recv() —— 接收服务端回声数据

```cpp
char buf[1024]{};
ssize_t len = ::recv(sockfd, buf, sizeof(buf) - 1, 0);
if (len < 0) {
    printf("recv error, code: %d, msg: %s\n", errno, strerror(errno));
} else if (len == 0) {
    printf("server closed connection\n");
} else {
    buf[len] = '\0';
    printf("recv: %s\n", buf);
}
```

### 原型

```c
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

### 返回值意义（和服务端完全相同）

- `> 0`：实际读到的字节数
- `== 0`：对端**正常关闭连接**（对方发了 FIN）
- `< 0`：出错，`errno` 里有错误码

这里注意两点：

1. `recv` 不会自动帮你加 `'\0'`
    - 所以用了 `buf[len] = '\0';`
    - 并且缓冲区大小是 `sizeof(buf) - 1`，留一个字节给终止符
2. 单线程同步阻塞：
    - 如果服务器暂时没发数据，`recv` 会阻塞在那儿等
    - 对 echo 服务来说，通常是：
        - 客户端 `send("hello")`
        - 服务端收到了，再立刻 `send` 回来
        - 客户端 `recv` 立刻拿到回声数据

------

## close() —— 关闭客户端 socket

```cpp
::close(sockfd);
```

- 告诉内核：这个 TCP 连接我用完了
- 会给对端发 FIN，进入 TCP 的挥手过程
- 调用后这个 `sockfd` 就不能再用来 `send/recv` 了

对 echo demo 来说：一次连接生命周期是：

1. 客户端：`socket` → `connect`
2. 客户端：`send("hello world")`
3. 服务端：收到后回一份
4. 客户端：`recv(...)` 打印
5. 客户端：`close` 连接结束

------

## TODO

在这个最简单的客户端基础上，可以继续往下玩：

1. **做成“长连接”客户端**
    - 现在是：连一次，发一句，收一次，就关。
    - 你可以在 `connect` 成功后，循环：
        - 从 `std::cin` 读一行
        - `send` 给服务器
        - `recv` 回声并打印
    - 输入 `quit` 时再关闭 socket。
2. **处理 send / recv 的“部分读写”**
    - 设计一个“先发长度再发数据”的协议：
        - 先 `send` 一个 4 字节长度（`htonl(len)`）
        - 再 `send` 正文
    - 客户端对应：
        - 先 `recv` 4 字节长度
        - 根据长度循环 `recv` 直到读满
3. **封装一个简单的 TcpClient 类（RAII 风格）**
    - 构造函数里 `socket + connect`
    - 析构函数里自动 `close`
    - 提供：
        - `bool sendAll(const void* buf, size_t len);`
        - `ssize_t recvSome(void* buf, size_t len);`
4. **改成非阻塞 / 使用 select**
    - 把客户端 socket 设为非阻塞
    - 或者用 `select` 同时监听 `stdin` 和 `socket`，做一个半双工聊天小程序