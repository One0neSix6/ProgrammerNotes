---
title: 简易 TCP 服务端
date: 2025-12-06 13:12:58
categories: 网络编程
tags: 套接字
---

> [参考教程](https://www.bilibili.com/video/BV1pu411G7P6?spm_id_from=333.788.player.switch&vd_source=8c404c2c8a2f3403260986ddd6884bb5&p=3)

单线程、同步、阻塞式 TCP echo 服务器示例代码：

```cpp
#include <iostream>
#include <cstring>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

int main() {
    // 关闭缓冲
    setbuf(stdout, nullptr);
    // 创建 socket
    int sockfd = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sockfd < 0) {
        printf("create socket error, code: %d, msg: %s\n", errno, strerror(errno));
        return -1;
    }
    printf("create socket success\n");

    std::string ip = "127.0.0.1";
    int port = 8080;
    sockaddr_in sockaddr = {};
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_addr.s_addr = inet_addr(ip.c_str());
    sockaddr.sin_port = htons(port);

    // 绑定 socket
    if (::bind(sockfd, reinterpret_cast<struct sockaddr*>(&sockaddr), sizeof(sockaddr)) < 0) {
        printf("socket bind error, code: %d, msg: %s\n", errno, strerror(errno));
        return 1;
    }
    printf("socket bind success, ip: %s, port: %d\n", ip.c_str(), port);

    // 监听 socket
    if (::listen(sockfd, 1024) < 0) {
        printf("socket listen error, code: %d, msg: %s\n", errno, strerror(errno));
        return 1;
    }
    printf("socket listen...\n");

    while (true) {
        // 等待客户端连接
        int connfd = ::accept(sockfd, nullptr, nullptr);
        if (connfd < 0) {
            printf("socket accept error, code: %d, msg: %s\n", errno, strerror(errno));
            break;
        }

        char buf[1024]{};
        // 接收客户端数据
        size_t dataLen = ::recv(connfd, buf, sizeof(buf), 0);
        if (dataLen < 0) {
            printf("recv data error, code: %d, msg: %s\n", errno, strerror(errno));
            continue;
        }
        if (dataLen == 0) {
            printf("client closed connection\n");
            continue;
        }

        printf("recv confd: %d, data: %s\n", connfd, buf);
        // 向客户端发送数据
        ::send(connfd, buf, dataLen, 0);
        ::close(connfd);
    }

    // 关闭 socket
    ::close(sockfd);
    return 0;
}
```

封装成 `class` 版本：

```cpp
// tcpServer.h
#pragma once

#include <iostream>
#include <cstring>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

class TcpServer {
public:
    TcpServer(const std::string& ip, int port);
    ~TcpServer();

    bool start();
    void run();
    void stop();
private:
    void handleClient(int connfd);
private:
    std::string m_ip;
    int m_port;
    int m_sockfd;
    bool m_running;
};
```

```cpp
// tcpServer.cpp
#include "TcpServer.h"

TcpServer::TcpServer(const std::string& ip, const int port) :
    m_ip(ip), m_port(port), m_sockfd(-1), m_running(false) {}

TcpServer::~TcpServer() {
    stop();
}

bool TcpServer::start() {
    // 创建 socket
    m_sockfd = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (m_sockfd < 0) {
        printf("create socket error, code: %d, msg: %s\n", errno, strerror(errno));
        return false;
    }
    printf("create socket success\n");

    sockaddr_in sockaddr = {};
    sockaddr.sin_family = AF_INET;
    sockaddr.sin_addr.s_addr = inet_addr(m_ip.c_str());
    sockaddr.sin_port = htons(m_port);

    // 绑定 socket
    if (::bind(m_sockfd, reinterpret_cast<struct sockaddr*>(&sockaddr), sizeof(sockaddr)) < 0) {
        printf("socket bind error, code: %d, msg: %s\n", errno, strerror(errno));
        stop();
        return false;
    }
    printf("socket bind success, ip: %s, port: %d\n", m_ip.c_str(), m_port);

    // 监听 socket
    if (::listen(m_sockfd, 1024) < 0) {
        printf("socket listen error, code: %d, msg: %s\n", errno, strerror(errno));
        stop();
        return false;
    }
    printf("socket listen...\n");

    m_running = true;
    return true;
}

void TcpServer::run() {
    if (m_sockfd < 0) {
        printf("server not started\n");
        return;
    }
    while (m_running) {
        // 等待客户端连接
        int connfd = ::accept(m_sockfd, nullptr, nullptr);
        if (connfd < 0) {
            printf("socket accept error, code: %d, msg: %s\n", errno, strerror(errno));
            break;
        }
        handleClient(connfd);
    }
}

void TcpServer::stop() {
    if (m_sockfd != -1) {
        ::close(m_sockfd);
        m_sockfd = -1;
    }
    m_running = false;
}

void TcpServer::handleClient(int connfd) {
    char buf[1024]{};
    // 接收客户端数据
    size_t dataLen = ::recv(connfd, buf, sizeof(buf) - 1, 0);
    if (dataLen < 0) {
        printf("recv data error, code: %d, msg: %s\n", errno, strerror(errno));
        ::close(connfd);
        return;
    }
    if (dataLen == 0) {
        printf("client closed connection\n");
        ::close(connfd);
        return;
    }
    buf[dataLen] = '\0';
    printf("recv confd: %d, data: %s\n", connfd, buf);
    // 向客户端发送数据
    ::send(connfd, buf, dataLen, 0);
    ::close(connfd);
}

```

```cpp
// server.cpp
#include "socket/TcpServer.h"

int main() {
    // 关闭缓冲
    setbuf(stdout, nullptr);

    TcpServer server("127.0.0.1", 8080);
    if (!server.start()) {
        return 1;
    }
    server.run();

    return 0;
}
```

## 整体流程

网络服务器端常见步骤：

1. `socket()` —— 创建一个 socket（套接字）
2. `bind()` —— 把 socket 绑定在某个 IP + 端口 上
3. `listen()` —— 监听
4. `accept()` —— 接收客户端连接
5. 用 `recv()` / `send()` 收发数据，用完之后 `close()` 关闭

## 相关头文件简介

```cpp
#include <sys/socket.h>   // socket, bind, listen, accept, recv, send 等函数
#include <netinet/in.h>   // sockaddr_in 结构体，AF_INET, htons 等
#include <arpa/inet.h>    // inet_addr, inet_pton 等
#include <unistd.h>       // close 函数
```

------

## 创建套接字

```cpp
int sockfd = ::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
```

### 参数含义

- `AF_INET`
     协议族（地址族），表示 **IPv4**。
    - IPv4：`AF_INET`
    - IPv6：`AF_INET6`
- `SOCK_STREAM`
     套接字类型，表示 **字节流** 类型，对应 TCP 协议。 如果是 UDP，一般用 `SOCK_DGRAM`（数据报）。
- `IPPROTO_TCP`
     协议，指定用 **TCP**。实际上这里可以写 `0`，让系统根据前两个参数自动选择合适协议；但写 `IPPROTO_TCP` 更明确。

### 返回值

- 成功：返回一个 **文件描述符 fd**（一个 int），后续所有 socket 操作都靠它。
- 失败：返回 `-1`，并且 `errno` 中有错误码。

------

## sockaddr_in

```cpp
std::string ip = "127.0.0.1";
int port = 8080;
sockaddr_in sockaddr = {};
sockaddr.sin_family = AF_INET;
sockaddr.sin_addr.s_addr = inet_addr(ip.c_str());
sockaddr.sin_port = htons(port);
```

`struct sockaddr_in` 是 **IPv4 地址结构体**，定义大致如下（简化）：

```c
struct sockaddr_in {
    sa_family_t    sin_family; // 地址族 AF_INET
    in_port_t      sin_port;   // 端口（网络字节序）
    struct in_addr sin_addr;   // IP 地址（网络字节序）
    // 还有一些填充字段
};
```

### sin_family

```cpp
sockaddr.sin_family = AF_INET;
```

表示使用 IPv4。这个必须和 `socket()` 的第一个参数一致（都是 `AF_INET`）。

### inet_addr()

```cpp
sockaddr.sin_addr.s_addr = inet_addr(ip.c_str());
```

`inet_addr` 的作用是把 `"127.0.0.1"` 这种点分十进制字符串转成一个 32 位的 IP 地址（**网络字节序**，大端）。

- 传入：C 字符串 `"127.0.0.1"`
- 返回：`in_addr_t` 类型（本质是 `uint32_t`）

### htons()

```cpp
sockaddr.sin_port = htons(port);
```

- `htons`：**h**ost to **n**etwork **s**hort
- 作用：把主机字节序（取决于 CPU，很多是小端）转成 **网络字节序（大端）**。
- 网络协议规定端口、IP 等都是大端传输的。

还有一对常见的：

- `htonl`：host to network **long**（32 位）
- `ntohs`/`ntohl`：network to host（收到数据转换回来）

------

## bind() 

```cpp
if (::bind(sockfd, reinterpret_cast<struct sockaddr*>(&sockaddr), sizeof(sockaddr)) < 0) {
    printf("socket bind error, code: %d, msg: %s\n", errno, strerror(errno));
    return -1;
}
```

### 原型

```c
int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
```

### 做了什么？

- 把 `sockfd` 这个 socket 绑定到：
    - `ip = 127.0.0.1`
    - `port = 8080`
- 从此以后，这个 socket 就代表本机这个地址。

### 参数说明

- `sockfd`：刚才 `socket()` 返回的 fd。
- `addr`：指向一个 `struct sockaddr` 的指针。
    - 而实际类型是 `sockaddr_in`，所以用了 `reinterpret_cast<struct sockaddr*>(&sockaddr)`。
- `addrlen`：结构体的大小 `sizeof(sockaddr_in)`。

### bind 常见错误

- `EADDRINUSE`：地址已被占用（端口被别的程序用了，或者刚刚用过，处于 TIME_WAIT）。
- `EACCES`：权限不够（比如绑定小于 1024 的端口需要 root 权限，某些系统）

------

## listen() 

```cpp
if (::listen(sockfd, 1024) < 0) {
    printf("socket listen error, code: %d, msg: %s\n", errno, strerror(errno));
    return -1;
}
```

### 原型

```c
int listen(int sockfd, int backlog);
```

### 做了什么？

- 把一个“普通的、已绑定地址的 socket”变成一个 **监听（被动）socket**。
- 内核会为它维护一个 **连接队列**，保存已经完成三次握手但你还没 `accept()` 的连接。

### 参数

- `backlog = 1024`：“最多同时排队的未 `accept()` 的连接数”的上限（具体行为由内核调节，不一定正好是 1024）。连接太多时，超出的可能会被丢弃或拒绝。

------

## accept() 

```cpp
int connfd = ::accept(sockfd, nullptr, nullptr);
```

### 原型

```c
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

### 做了什么？

- 从 `sockfd` 的连接队列中**取出一个已完成的连接**。
- 返回一个新的文件描述符 `connfd`，代表“和某个客户端之间的一条 TCP 连接”。

之后的数据收发都用这个 `connfd`，**不是原来的 `sockfd`**。 `sockfd` 一直用来继续 `accept()` 新的连接。

### 参数

- `sockfd`：监听 socket。
- `addr` / `addrlen`：用于获取对端（客户端）的地址信息。
    - 传的是 `nullptr, nullptr`，表示不关心客户端 IP/端口。

### 阻塞行为

在默认情况下，`accept()` 是**阻塞**的：

- 没有新连接到来时，进程就停在这里等待。
- 直到有客户端连接成功（完成三次握手）才返回。

------

## recv() 

```cpp
char buf[1024]{};
size_t dataLen = ::recv(connfd, buf, sizeof(buf), 0);
```

### 原型

```c
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

### 含义

- `sockfd`：这里是 `connfd`，即一条具体连接。
- `buf`：用来存放收到的数据。
- `len`：缓冲区大小，这里是 `sizeof(buf)`。
- `flags`：一般写 0，进阶用法可以传 `MSG_PEEK` 等标志。

### 返回值

- `> 0`：实际读取到的字节数。
- `== 0`：对端**正常关闭连接**（FIN）。
- `< 0`：出错，`errno` 里有错误码。

------

## send()

```cpp
::send(connfd, buf, dataLen, 0);
```

### 原型

```c
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
```

### 含义

- 把 `buf` 里的 `len` 字节数据，通过 `sockfd` 这条 TCP 连接发给对端。

### 返回值

- 成功：实际发送的字节数 `> 0`
- 失败：返回 `-1`，`errno` 中有错误码。

> **重要：** `send()` 不保证一次就发完你给的所有数据，有可能只发了一部分，需要循环发送：
>
> ```cpp
> ssize_t n = send(connfd, buf, dataLen, 0);
> // n 可能 < dataLen
> ```
>
> 对于简单的 demo，先不考虑这个细节，但实际项目要处理。

这里是 **回声服务器**：收到啥，就原样 `send` 回去。

------

## close() 

```cpp
::::close(connfd);  // 每次处理完一个客户端就关闭连接
...
::close(sockfd);  // 主循环退出后，关闭监听 socket
```

### 原型

```c
int close(int fd);
```

- `fd` 是一个文件描述符，既可以是普通文件，也可以是 socket。
- 调用 `close(connfd)` 会关闭这条 TCP 连接，给对端发 FIN。

对于服务器：

- 每个客户端连接用一个 `connfd`，处理完就 `close`。
- 程序结束前别忘了关掉 `sockfd`（监听 socket）。

## TODO

在这个基础上继续深入：

1. **改成多客户端并发**
    - 多线程：每次 `accept` 后新建一个线程处理 `connfd`
    - I/O 多路复用：`select` / `poll` / `epoll` 等
2. **更安全的读写**
    - 处理 `send` 部分发送、`recv` 粘包/拆包问题。
    - 设计应用层协议（比如消息先发长度）。
3. **更现代的接口**
    - 用 `inet_pton` / `inet_ntop` 代替 `inet_addr`。

