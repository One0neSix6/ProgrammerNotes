---
title: TCP/IP网络编程笔记11
date: 2025-12-14 11:23:10
categories: 网络编程
tags: TCP/IP网络编程
---

------

# 第十三章

## 本章整体定位

书名：**《TCP/IP 网络编程》（尹圣雨）**
第 13 章标题：**多种 I/O 函数**

本章是在前面已经会用 `read` / `write`、`recv` / `send` 做收发数据的基础上，补充一些**更灵活的 I/O 函数和选项**，主要包括：

1. `send` / `recv` 函数（带各种 `flags` 选项）
2. TCP 紧急消息（Out-of-band，`MSG_OOB`）
3. `MSG_PEEK` + `MSG_DONTWAIT` 检查接收缓冲
4. 分散/集中 I/O：`readv` / `writev`

、可以把这一章理解为：**在已有 I/O 模型上增加“附加功能键”**。

------

## 基本 I/O 回顾

### UNIX 通用 I/O

```c
ssize_t read (int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
```

- 适用于**所有**文件描述符（普通文件、管道、socket…）。
- 没有额外选项，就是老老实实读 / 写。

### socket 增强的 I/O

```c
#include <sys/socket.h>

ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);
ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags);
```

和 `read` / `write` 对比：

- 前 3 个参数本质一样：
    - `sockfd`：socket fd
    - `buf`：缓冲区指针
    - `nbytes`：发送 / 接收的最大字节数
- **多了一个 `flags` 参数**：
    - 通过各种宏（`MSG_OOB`、`MSG_PEEK` 等）控制行为。
- 返回值语义也类似：
    - 成功：返回实际发送 / 接收的字节数（`recv` 收到 EOF 返回 0）。
    - 失败：返回 -1，并设置 `errno`。

> 在不需要特殊选项时，`send/recv` 和 `write/read` 可以互换使用，大多数 demo 里都会直接用 `read` / `write`。本章的重点就是：**什么时候你会需要 `flags`。**

------

## 常用选项

书里重点整理了几个常见的选项：

| 选项            | 作用概述                            | `send` 支持 | `recv` 支持 |
| --------------- | ----------------------------------- | ----------- | ----------- |
| `MSG_OOB`       | 带外（紧急）数据                    | ✅           | ✅           |
| `MSG_PEEK`      | 只“偷看”接收缓冲，不消费数据        | ❌           | ✅           |
| `MSG_DONTROUTE` | 不查本地路由表，直接在本地网段找    | ✅           | ❌           |
| `MSG_DONTWAIT`  | 非阻塞 I/O（相当于临时 O_NONBLOCK） | ✅           | ✅           |
| `MSG_WAITALL`   | 一定要收满指定字节才返回            | ❌           | ✅           |

不同系统支持程度不完全一致，Linux 一般都支持上面这些；写跨平台代码时要查对应平台文档。

下面挑重点几个说明。

------

### MSG_OOB

#### 概念

- 名字叫“带外数据 / 紧急数据”，但在 TCP 里 **并不是真的走“另一条通道”**。
- 实际上是：
    - 在正常数据流中打一个“**紧急指针**”标记，
    - 告诉对方：“到这里为止，前一个字节是紧急数据，你要赶紧处理它。”

> 所以：**紧急数据真正意义上只有 1 个字节**（紧急指针指向的位置前一个字节），剩下的还是普通数据。

#### 发送紧急数据

只要在 `send` 的 `flags` 参数里加上 `MSG_OOB` 即可：

```c
send(sock, "123", 3, 0);               // 普通数据
send(sock, "4",   1, MSG_OOB);         // 紧急数据（只有 '4' 真正是 OOB）
send(sock, "567", 3, 0);               // 普通数据
```

- 对端依然按顺序收到：`1234567...`，
- 只是可以通过特殊方式把 `'4'` 单独捞出来（比如专门用 `recv(..., MSG_OOB)` 读取）。

#### 接收紧急数据（Linux 示例）

书里给的是**服务端**处理紧急数据的例子，一般步骤是：

1. 用 `sigaction` 注册 `SIGURG` 信号处理函数。
2. 调用 `fcntl(recv_sock, F_SETOWN, getpid());` 指定哪个进程接收该 socket 的 `SIGURG` 信号。
3. 收到 `SIGURG` 信号时，在信号处理函数里调用 `recv(..., MSG_OOB)` 读取紧急字节。

oob_send.c 代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define BUF_SIZE 30

void error_handling(char* message);

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("port is null\n");
        exit(1);
    }

    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == -1) {
        error_handling("socket() error");
    }
    
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    server_addr.sin_port = htons(atoi(argv[1]));

    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        error_handling("connect() error");
    }

    char* msg1 = "123";
    char* msg2 = "45";
    char* msg3 = "67";
    char* msg4 = "890";
    write(sock, msg1, strlen(msg1));
    send(sock, msg2, strlen(msg2), MSG_OOB);
    write(sock, msg3, strlen(msg3));
    send(sock, msg4, strlen(msg4), MSG_OOB);

    close(sock);

    return 0;
}

void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}

```

oob_recv.c 代码：

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <signal.h>
#include <errno.h>

#define BUF_SIZE 30

void error_handling(char* message);
void urg_hander(int sig);

int server_sock, client_sock;

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("port is null\n");
        exit(1);
    }

    server_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (server_sock == -1) {
        error_handling("socket() error");
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(atoi(argv[1]));

    if (bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        error_handling("bind() error");
    }

    if (listen(server_sock, 5) == -1) {
        error_handling("listen() error");
    }

    client_sock = accept(server_sock, NULL, NULL);
    if (client_sock == -1) {
        error_handling("accept() error");
    }

    struct sigaction action;
    action.sa_handler = urg_hander;
    sigemptyset(&action.sa_mask);
    action.sa_flags = 0;

    fcntl(client_sock, F_SETOWN, getpid());
    sigaction(SIGURG, &action, 0);

    int str_len;
    char buf[BUF_SIZE];
    while ((str_len = recv(client_sock, buf, BUF_SIZE - 1, 0)) != 0) {
        if (str_len == -1) {
            if (errno == EINTR) {
                continue;
            }
            break;
        }
        buf[str_len] = '\0';
        printf("message: %s\n", buf);
    }

    close(server_sock);
    close(client_sock);

    return 0;
}

void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}

void urg_hander(int sig) {
    if (sig != SIGURG) {
        return;
    }
    char buf[BUF_SIZE];
    int str_len = recv(client_sock, buf, BUF_SIZE - 1, MSG_OOB);
    if (str_len <= 0) {
        return;
    }
    buf[str_len] = '\0';
    printf("Urgent message: %s\n", buf);
}

```

关键点：

- **紧急数据只会有一个字节被 `MSG_OOB` 单独读出**，其余仍走普通通道。
- 紧急模式的真实作用：**“督促”对端尽快处理某个位置之前的数据**，并不是“更快到达”。

在实际业务中，`MSG_OOB` 用得不算多，更常见的是应用层自己设计“控制消息”。

------

### MSG_PEEK + MSG_DONTWAIT

目标：**不阻塞**的情况下，看看 socket 上“有没有东西可以读”。

思路：

- `MSG_PEEK`：从接收缓冲中**偷看数据**，但不把数据移除。
- `MSG_DONTWAIT`：让本次 `recv` 变成非阻塞，如果当前没有数据，立即返回 `-1`，`errno = EAGAIN` 或 `EWOULDBLOCK`。

组合使用：

```c
int len = recv(sock, buf, sizeof(buf), MSG_PEEK | MSG_DONTWAIT);
if (len > 0) {
    // 缓冲里有数据，但还没被拿走，可以决定等会儿再真正 read 一次
} else if (len == -1 && errno == EAGAIN) {
    // 暂时没有数据
}
```

peek_send.c 代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define BUF_SIZE 30

void error_handling(char* message);

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("port is null\n");
        exit(1);
    }

    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == -1) {
        error_handling("socket() error");
    }
    
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    server_addr.sin_port = htons(atoi(argv[1]));

    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        error_handling("connect() error");
    }
    sleep(1);
    char* msg1 = "123";
    write(sock, msg1, strlen(msg1));

    close(sock);

    return 0;
}

void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}

```

peek_recv.c 代码：

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <signal.h>
#include <errno.h>

#define BUF_SIZE 30

void error_handling(char* message);

int server_sock, client_sock;

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("port is null\n");
        exit(1);
    }

    server_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (server_sock == -1) {
        error_handling("socket() error");
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(atoi(argv[1]));

    if (bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        error_handling("bind() error");
    }

    if (listen(server_sock, 5) == -1) {
        error_handling("listen() error");
    }

    client_sock = accept(server_sock, NULL, NULL);
    if (client_sock == -1) {
        error_handling("accept() error");
    }

    int str_len;
    char buf[BUF_SIZE];
    while (1) {
        str_len = recv(client_sock, buf, BUF_SIZE - 1, MSG_PEEK | MSG_DONTWAIT);
        if (str_len > 0) {
            buf[str_len] = '\0';
            printf("read message: %s\n", buf);
            break;
        }
        printf("wait...\n");
    }
    str_len = recv(client_sock, buf, BUF_SIZE - 1, 0);
    if (str_len > 0) {
        buf[str_len] = '\0';
        printf("read message again: %s\n", buf);
    }

    close(server_sock);
    close(client_sock);

    return 0;
}

void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}

```

这个技巧在你想“**提前知道一次性能读到多少数据**”时会很有用。

## 分散/集中 I/O

这一对函数是本章的另一个重点：**一次调用读/写多个缓冲区**，也叫 **scatter / gather I/O**。

### 函数原型

```c
#include <sys/uio.h>

ssize_t readv (int fd, const struct iovec* iov, int iovcnt);
ssize_t writev(int fd, const struct iovec* iov, int iovcnt);
```

结构体 `iovec`：

```c
struct iovec {
    void* iov_base;    // 缓冲区起始地址
    size_t iov_len;    // 缓冲区长度
};
```

参数说明：

- `fd`：文件描述符，可以是 socket，也可以是普通文件、标准输出等。
- `iov`：`iovec` 数组指针，每一项代表一块缓冲。
- `iovcnt`：数组元素个数。

### writev 集中写

场景：你有**多块分散的发送数据**，比如：

- 一块是协议头 `header[ ]`
- 一块是正文 `body[ ]`

普通写法：

```c
write(fd, header, header_len);
write(fd, body,   body_len);
```

`writev` 写法：

```c
struct iovec iov[2];
iov[0].iov_base = header;
iov[0].iov_len  = header_len;
iov[1].iov_base = body;
iov[1].iov_len  = body_len;

ssize_t sent = writev(fd, iov, 2);
```

优点：

1. **系统调用次数减少**（一次 `writev` 代替多次 `write`）；
2. 内核可以一次性从多个缓冲中拷贝，避免你自己 `memcpy` 拼一个大 buffer。

### readv 分散读

反过来，readv 可以把从 fd 读到的数据自动拆到多个缓冲里，比如：

```c
char header[10];
char body[1024];
struct iovec iov[2];

iov[0].iov_base = header;
iov[0].iov_len  = sizeof(header);
iov[1].iov_base = body;
iov[1].iov_len  = sizeof(body);

ssize_t n = readv(fd, iov, 2);
// 前 10 字节进 header，后面进 body
```

典型用途：

- 协议头 / 数据体分离存放；
- 接收到的数据天然分块时，不用再拆分拷贝。

------

## Windows 平台相关说明（简略）

本章最后还给了 Windows 上的一些对应实现，大致要点：

- `send` / `recv` 在 Windows 上函数名相同，但 socket 类型是 `SOCKET`，错误用 `WSAGetLastError()` 查看。
- 紧急数据同样通过 `MSG_OOB`，不过 signal 机制不同，通常会用：
    - `WSAAsyncSelect` 或 `select` 来监听 `FD_OOB` 事件。
- 分散 / 集中 I/O 对应：
    - `WSASend` / `WSARecv` + `WSABUF` 数组，作用类似 `writev` / `readv`。

如果你主要在 Linux 下学习，可以先把 Linux 这部分搞懂，把 Windows 当作“接口名不同，但思想一样”。

------

## 本章小结

1. **`send` / `recv` = `write` / `read` + `flags`**
    - 普通收发时 `flags = 0` 即可。
    - 需要“特殊姿势”时，用 `MSG_OOB` / `MSG_PEEK` / `MSG_DONTWAIT` / `MSG_WAITALL` 等扩展行为。
2. **紧急数据（`MSG_OOB`）并不是真的“走另一条线”**
    - 本质是一个“紧急指针”，强调“优先处理某个位置之前的数据”。
    - 实战中用得不多，但要知道它的语义和基本用法。
3. **`MSG_PEEK` + `MSG_DONTWAIT` 可以用来“探测”输入缓冲**
    - 想知道“现在有没有数据、数据大概多长”，但又不想阻塞 / 不想把数据读走时用它。
4. **`readv` / `writev` = 分散/集中 I/O**
    - 一次调用读/写多块缓冲，减少系统调用次数。
    - 很适合“头 + 体”、“多段消息”这类结构化数据的发送与接收。
5. **跨平台差异**
    - Linux 和 Windows 在概念上类似，接口名称和细节不同。
    - Windows 下有 `WSASend` / `WSARecv`、异步事件 `FD_OOB` 等，对标本章的 Linux 示例。

这一章的所有内容，实质上都是在回答一个问题：

> “在已经有 `read/write` 的情况下，**我们还需要哪些更灵活的 I/O 操作手段？**”

