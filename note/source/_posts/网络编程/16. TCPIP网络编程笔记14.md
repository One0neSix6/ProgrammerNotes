---
title: TCP/IP网络编程笔记14
date: 2025-12-14 15:32:15
categories: 网络编程
tags: TCP/IP网络编程
---

------

# 第十六章

------

## 本章整体定位

书名：**《TCP/IP 网络编程》（尹圣雨）**
第 16 章标题：**关于 I/O 流分离的其他内容**

这一章是在：

- 第 10 章：用 `fork` 把“读写逻辑”分到父子进程里；
- 第 15 章：用 `fdopen` 把同一个 socket 分成两个 `FILE*`（读流 / 写流）；

的基础上，进一步讨论：

1. 什么叫“**I/O 流分离**”，之前到底已经做了什么。
2. “流分离”有什么好处，尤其是对代码结构和缓冲性能。
3. 使用标准 I/O 进行“流分离”时会遇到一个典型坑：**EOF 不能正确传递**。
4. 如何通过 **复制文件描述符（`dup` / `dup2`）+ `shutdown`** 正确实现“半关闭 + 流分离”。

可以把这一章理解为：

> 「用标准 I/O 优雅写 socket 后，**如何正确地“只关写、不关读”**？」

------

## 分离 I/O 流

### “分离 I/O 流”在书里的意思

书里的“流（I/O stream）”主要指：

- **输入流**：从 socket 里读数据的那一套逻辑/对象；
- **输出流**：往 socket 里写数据的那一套逻辑/对象。

“分离 I/O 流”就是：

> **把“读”和“写”彻底拆开，单独处理**。
> 代码上、对象上都分成“读一边 / 写一边”，互不干扰。

在前面章节中，书其实已经做过“2 次流分离”：

1. **第 10 章（多进程 echo 客户端）**
    - 用 `fork()`：父进程负责 `read`，子进程负责 `write`（或反过来）。
    - 这样“读代码”和“写代码”在两个进程里，各写各的逻辑，不互相搅在一起。
2. **第 15 章（标准 I/O + socket）**
    - 用 `fdopen` 同一个 socket：
        - `FILE* readfp = fdopen(sock, "r");`
        - `FILE* writefp = fdopen(sock, "w");`
    - 从此往后，“读”只用 `fgets(readfp)`，“写”只用 `fputs(writefp)`。

------

### 流分离带来的好处

书里总结了两个层面的好处：

1. **代码结构更清晰、复杂逻辑更好拆分**
    - 读逻辑和写逻辑分开写：
        - 可以分别处理“接收数据”“打印 / 解析”等；
        - 输出端可以单独优化，不用顾虑输入状态。
    - 在多进程 / 多线程场景中，也便于协作分工。
2. **缓冲更高效**
    - 标准 I/O 有**独立的缓冲区**：读缓冲 / 写缓冲。
    - 把读写分开：
        - 读流只关心“怎么把 socket 的数据读入缓冲”；
        - 写流只关心“如何把用户数据堆进缓冲、什么时候 flush”。

> 流分离 = 解耦逻辑 + 用好缓冲**。
> 但随之而来的就是本章的问题：**EOF 到底怎么传？**

------

## 流分离带来的 EOF 问题

### 回顾：EOF 和半关闭

在之前的章节，已经见过：

```c
shutdown(sock, SHUT_WR);  // 只关闭“写”方向（发送 FIN）
```

这个动作用于：

- 告诉对端：“我这边**不会再发数据了**，但是我还会继续收你发来的数据。”
- 对端 `read`/`recv` 就会在读完已有数据后收到 **0 字节（EOF）**。

这就是典型的 **TCP 半关闭（half-close）**。

------

### 用标准 I/O + fclose 会出什么事

书里给了一个“错误写法”的例子（`sep_serv.c` / `sep_clnt.c`）：

- 服务器通过 `fdopen` 把 socket 变成两个 `FILE*`（读/写）；

- 写完之后，为了给对端发 EOF，就这么干：

    ```c
    fclose(writefp);  // 以为是“只关闭输出流”
    ```

表面以为：只关闭输出方向，读流还能继续用。
但实际发生的是：**socket 整个被关掉了，读也没了**。

**原因在于：**

- 这两个 `FILE*`（读流和写流）是通过 **同一个文件描述符 fd** 创建的。
- `fclose(writefp)` 会：
    1. 刷新写缓冲；
    2. **关闭底层 fd**；
    3. 导致**另一个基于同一 fd 的 `readfp` 也失效** —— 再读就出错。

这样就不是半关闭，而是 **整个连接直接断了**。
所以那段错误示例的表现是：服务器端收不到客户端后续发来的字符串。

书中结论：

> 单纯用两个 `FILE*` 包裹同一 fd，
> 对其中一个 `FILE*` 调 `fclose`，**不是半关闭，只是把这个 fd 也关了**，
> 还剩下的那个 `FILE*` 其实已经没法正常用了。

------

## 文件描述符的复制和半关闭

核心思路：

> 想“只关写、不关读”，
> 那就先**复制一个文件描述符**，让读 / 写各用一个 fd。

### 文件描述符复制

#### 原型

```c
#include <unistd.h>

int dup(int oldfd);
int dup2(int oldfd, int newfd);
/*
 * 成功：返回新的文件描述符
 * 失败：返回 -1
 */
```

- `dup(oldfd)`：
    - 找到当前进程中尚未使用的**最小编号 fd**，复制一份引用到同一个“打开文件/套接字对象”上。
- `dup2(oldfd, newfd)`：
    - 你**指定 newfd** 的数值：
        - 如果 `newfd` 已经被占用，会先 `close(newfd)`，
        - 然后让 `newfd` 成为 `oldfd` 的副本。

复制之后的两个 fd：

- 指向同一个内核的“打开文件/套接字”结构；

- 例如：

    ```c
    int fd1 = socket(...);
    int fd2 = dup(fd1);
    ```

    这两个都能对 **同一个 TCP 连接** 读写；
    内核会为这两个 fd 共用一个“文件状态”：

    - 文件偏移（对普通文件）
    - 套接字缓冲 / TCP 状态等。

书里特别强调了一个关系：

> **只有和某个 socket 关联的所有 fd 都被关闭之后，这个 socket 才会真的被销毁。**

- 你有 `fd1`、`fd2` 都引用同一个 socket：
    - `close(fd1)` 只会让 **引用计数 -1**；
    - 只要 `fd2` 还活着，连接就还在。

这就给我们提供了操作空间：

- 可以把“写”这边的 fd 关掉，
- 把“读”这边的 fd 保留，
- 再配合 `shutdown` 控制半关闭。

------

## 复制 fd 

思路分两步

1. **fd 层面：复制描述符，实现真正的读写分离**
    - `int sock = accept(...);`
    - `int sock_read = dup(sock);`
    - `int sock_write = sock;`
    - 然后：
        - `FILE* readfp = fdopen(sock_read, "r");`
        - `FILE* writefp = fdopen(sock_write, "w");`
    - 这样：
        - 关闭 `writefp` → 只减少一个 fd 的引用计数；
        - 读流 `readfp` 对应的 `sock_read` 仍然有效。
2. **协议层面：用 `shutdown` 发送 EOF**
    - 单纯 `fclose(writefp)` 只是关掉一个 fd，并**不会发送半关闭（EOF）**；
    - 需要在合适的时机对某个 fd 调 `shutdown(fd, SHUT_WR)`，来告诉对端“我不再发送数据了”。

所以比较规范的一套流程可以是：

```c
int sock = accept(...);

// 复制文件描述符
int sock_read  = dup(sock);
int sock_write = sock;

// 标准 I/O 封装
FILE*readfp  = fdopen(sock_read,  "r");
FILE* writefp = fdopen(sock_write, "w");

// 写端：发完所有数据
fputs("Hi~ client?\n", writefp);
fputs("I love all of the world\n", writefp);
fputs("You are awesome!\n", writefp);
fflush(writefp);

// 半关闭：告诉对端“发送完了”
shutdown(sock_write, SHUT_WR);

// 写 FILE 可以关掉了
fclose(writefp);

// 读端：继续等对方回一句话
char buf[BUFSIZ];
if (fgets(buf, sizeof buf, readfp) != NULL) {
    printf("FROM CLIENT: %s\n", buf);
}

// 最后把读 FILE 也关闭（引用计数归零，真正断开）
fclose(readfp);
```

书里 `sep_serv2.c / sep_clnt.c` 的效果就是：

- 服务器先向客户端发 3 行；
- 调用 `shutdown(..., SHUT_WR)` 把“写方向”半关闭（对端会读到 EOF）；
- 客户端收到 EOF 后再发一句 “Thank you” 回来；
- 服务器还能**继续正常读到这句话**，证明流分离 + 半关闭成功。

### 对比

错误示例中（未用 `dup`）：

```c
FILE* readfp  = fdopen(sock, "r");
FILE* writefp = fdopen(sock, "w");

// 写完：
fclose(writefp);  // 直接关掉底层 fd
```

效果：

- 对应的 `sock` 已经被 close 掉；
- `readfp` 里的 fd 也失效了（虽说 FILE* 还在，但里面的 fd 已经坏了）；
- 所以服务器端根本收不到客户端回来的那句 `"Thank you"`。

------

## 本章小结

把第 16 章浓缩一下，就是下面几条：

1. **I/O 流分离 = 把“读”和“写”从逻辑上、对象上拆开**
    - 第 10 章：用 `fork` 把读/写分别放进父子进程。
    - 第 15 章：用 `fdopen` 再分成读 FILE 和写 FILE。
2. **流分离的好处**：
    - 代码清晰：输入逻辑 / 输出逻辑互相独立；
    - 性能好：读写各有缓冲，标准 I/O 能更高效。
3. **标准 I/O 直接 `fclose` 会把底层 fd 一起关掉**：
    - `fdopen` 出来的两个 `FILE*` 如果共用一个 fd，
    - 你对任意一个 `FILE*` 调 `fclose` → fd 关掉 → 另一个 `FILE*` 也废了 → 不是半关闭，而是直接断线。
4. **正确姿势 = 复制 fd + fdopen + shutdown**：
    - 用 `dup` / `dup2` 把 socket fd 复制一份，让读写各用一个 fd；
    - 读写 FILE 分别基于不同 fd 创建；
    - 写完后：
        - `shutdown(写fd, SHUT_WR)` 发送 EOF（半关闭输出）；
        - 关闭写 FILE，不影响读 FILE；
        - 读 FILE 还能继续读到对端的数据。
5. **真正关闭连接**：
    - 当所有和该 socket 关联的 fd 都被 `close` / `fclose` 掉，
    - 内核才彻底销毁这个 socket 及其资源。

如果你愿意，下一步可以基于你之前的 echo 客户端 / 服务器，把它们重写一版：

- 在客户端：用 `fdopen + 流分离 + shutdown` 实现“键盘输入一段 → 发给服务器 → 输入 `q` 时只关闭写端，但继续收服务端返回的信息”；
- 在服务器端：用 `dup + fdopen` 正确处理半关闭。