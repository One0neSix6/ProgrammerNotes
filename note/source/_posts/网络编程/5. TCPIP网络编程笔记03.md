---
title: TCP/IP网络编程笔记03
date: 2025-12-07 20:17:58
categories: 网络编程
tags: TCP/IP网络编程
---

## IP 地址和端口号

### IP 地址（以 IPv4 为例）

- IPv4 地址 = **32 位无符号整数**
- 通常写成点分十进制：`192.168.1.10`
- 从操作系统视角，它就是一个 `uint32_t`（4 字节）

IP 地址的作用：

> 用来标识 **“哪一台机器”**。

### 端口号（Port）

- 端口号 = **16 位无符号整数**（0 ~ 65535）
- 表示这台机器上的 **“哪个应用/服务”**

常见端口示例：

| 服务  | 默认端口 |
| ----- | -------- |
| HTTP  | 80       |
| HTTPS | 443      |
| SSH   | 22       |
| MySQL | 3306     |

> **总结：**
>
> - IP：找到哪台电脑
> - 端口：找到这台电脑上的哪个程序

组合起来：

```text
192.168.1.10:8080
```

这才唯一定位到一个网络服务。

------

## sockaddr_in

IPv4 下常用的 C 语言结构体：

```c
struct sockaddr_in {
    sa_family_t    sin_family; // 地址族
    in_port_t      sin_port;   // 端口号（网络字节序）
    struct in_addr sin_addr;   // IP 地址（网络字节序）
    unsigned char  sin_zero[8];// 填充用
};

struct in_addr {
    uint32_t s_addr;           // 32 位 IP 地址（网络字节序）
};
```

逐个解释：

1. `sin_family`

- 类型：`sa_family_t`
- 常见值：
    - `AF_INET`：IPv4
    - （IPv6：`AF_INET6`，配合 `sockaddr_in6` 使用）
- 用途：告诉内核这是 **哪种地址类型**

> 注意：`socket()` 里用的是 `PF_INET` / `AF_INET`，`sockaddr_in.sin_family` 一般填 `AF_INET`。

2. `sin_port`

- 类型：`in_port_t`（通常是 `uint16_t`）
- **单位：端口号**
- **必须使用网络字节序（大端）**

例如绑定 4000 端口：

```c
addr.sin_port = htons(4000);
```

不能直接写 `addr.sin_port = 4000;`，否则在小端机器上会颠倒高低字节。

3. `sin_addr`

- 类型：`struct in_addr`
- 里面只有一个成员：`uint32_t s_addr;`
- **同样必须是网络字节序（大端）**

常见设置方式：

```c
// 服务器：绑定所有本机 IP
addr.sin_addr.s_addr = htonl(INADDR_ANY);

// 服务器/客户端：绑定/连接具体 IP
inet_pton(AF_INET, "192.168.1.100", &addr.sin_addr);
```

4. `sin_zero`

- 只是一块 **填充字段（padding）**，为了让 `sockaddr_in` 和通用 `sockaddr` 长度一致
- 一般设为 0：

```c
memset(&addr, 0, sizeof(addr));  // 一次性清零最简单
```

------

## 大端序、小端序与网络字节序

### 大端序（Big-endian）

- **高位字节存在低地址**
- 人类写数字习惯类似：最高位在左边
- 例如：`0x12345678` （4 字节）

内存布局（地址从低到高）：

```text
12 34 56 78
```

------

### 小端序（Little-endian）

- **低位字节存在低地址**
- 常见于 x86/x86_64 架构（PC 大多是小端）

同样 `0x12345678` 在小端机器中的内存布局：

```text
78 56 34 12
```

------

### 网络字节序（Network Byte Order）

约定俗成：**网络字节序 = 大端序**

原因：早期网络协议标准选了大端，于是大家都跟着用。
 无论主机是小端还是大端，**在网络上传输时一律用大端**。
 这样不同架构的机器才能互相通信。

------

## 主机字节序和网络字节序互转

**头文件：**

```c
#include <arpa/inet.h>
#include <netinet/in.h>
```

### 主机 ↔ 网络（整型端口 / IP）

#### 16 位（端口号）

```c
uint16_t htons(uint16_t hostshort); // host to network short
uint16_t ntohs(uint16_t netshort);  // network to host short
```

用途：

```c
addr.sin_port = htons(4000);        // 设置端口（主机 → 网络）

uint16_t port = ntohs(addr.sin_port); // 获取端口（网络 → 主机）
```

------

#### 32 位（IPv4 地址）

```c
uint32_t htonl(uint32_t hostlong);  // host to network long
uint32_t ntohl(uint32_t netlong);   // network to host long
```

设置 INADDR_ANY：

```c
addr.sin_addr.s_addr = htonl(INADDR_ANY);
```

------

### 文本 IP ↔ 二进制 IP

#### 文本 → 二进制（字符串 → in_addr）

```c
int inet_pton(int af, const char *src, void *dst);
```

示例：

```c
struct sockaddr_in addr;
inet_pton(AF_INET, "192.168.0.100", &addr.sin_addr);
```

------

#### 二进制 → 文本（in_addr → 字符串）

```c
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
```

示例：

```c
char ipstr[INET_ADDRSTRLEN];
inet_ntop(AF_INET, &addr.sin_addr, ipstr, sizeof(ipstr));
printf("IP = %s\n", ipstr);
```

> 老函数 `inet_addr` / `inet_aton` / `inet_ntoa` 也可以用，但 `inet_pton/inet_ntop` 更新、更通用（支持 IPv6）。

------

## 为什么服务端 IP 可以填 INADDR_ANY

### INADDR_ANY 的含义

```c
#define INADDR_ANY  ((in_addr_t) 0x00000000)  // 即 0.0.0.0
```

表示：**“所有本机地址”**。

服务端绑定时：

```c
addr.sin_family      = AF_INET;
addr.sin_port        = htons(4000);
addr.sin_addr.s_addr = htonl(INADDR_ANY);
bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));
```

意味着：

> 让这个 socket 监听 **本机所有网卡 IP** 上的 4000 端口。

例：如果你的机器有：

- 127.0.0.1（本地回环）
- 192.168.1.10（内网）
- 10.0.0.5（另一个网卡）

那么：

- 客户端连 `127.0.0.1:4000`
- 或 `192.168.1.10:4000`
- 或 `10.0.0.5:4000`

都能连到同一个服务器进程。

------

## bind 和 connect 函数详解

### bind —— 给 socket 绑定本地地址

**原型：**

```c
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

- `sockfd`：`socket()` 返回的套接字描述符
- `addr`：本地地址（一般是 `sockaddr_in` 强转成 `sockaddr*`）
- `addrlen`：结构体大小 `sizeof(struct sockaddr_in)`

**作用（TCP 服务端常见流程）：**

1. `socket()` 创建套接字
2. `bind()` 绑定本机 IP+端口（例如 `0.0.0.0:4000`）
3. `listen()` 开始监听
4. `accept()` 接受客户端连接

服务端典型写法：

```c
int sock = socket(AF_INET, SOCK_STREAM, 0);

struct sockaddr_in addr;
memset(&addr, 0, sizeof(addr));
addr.sin_family      = AF_INET;
addr.sin_port        = htons(4000);             // 监听端口 4000
addr.sin_addr.s_addr = htonl(INADDR_ANY);       // 所有本地 IP

bind(sock, (struct sockaddr*)&addr, sizeof(addr));
listen(sock, 5);
```

> 客户端也可以 `bind()`（比如想固定源端口），但通常不需要，操作系统会自动分配临时端口。

------

### connect —— 客户端发起连接

**原型：**

```c
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

- `sockfd`：`socket()` 创建的套接字
- `addr`：对端（服务器）的 IP+端口
- `addrlen`：结构大小

**作用：**

> 向服务器发起连接请求（对于 TCP，就是发起“三次握手”）。

客户端典型写法：

```c
int sock = socket(AF_INET, SOCK_STREAM, 0);

struct sockaddr_in serv;
memset(&serv, 0, sizeof(serv));
serv.sin_family = AF_INET;
serv.sin_port   = htons(4000);
inet_pton(AF_INET, "192.168.1.100", &serv.sin_addr);

connect(sock, (struct sockaddr*)&serv, sizeof(serv));

// 连接成功后就可以 send/recv
```

**内部发生了什么（TCP）：**

1. 客户端发送 SYN 包给服务器
2. 服务器回复 SYN+ACK
3. 客户端发送 ACK

三次握手成功后，`connect()` 返回 0，socket 进入已连接状态，可以使用 `send()` / `recv()` 通信。

