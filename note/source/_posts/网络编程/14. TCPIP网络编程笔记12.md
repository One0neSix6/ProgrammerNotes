---
title: TCP/IP网络编程笔记12
date: 2025-12-14 12:00:15
categories: 网络编程
tags: TCP/IP网络编程
---

------

# 第十四章

## 本章整体定位

书名：**《TCP/IP 网络编程》（尹圣雨）**
第 14 章标题：**多播与广播**

本章主要内容：

1. 为什么需要“一发多收”的传输方式（多播 / 广播）。
2. **多播（Multicast）** 的原理、地址范围、常用套接字选项和基本示例。
3. **广播（Broadcast）** 的原理、广播地址、本地广播与直接广播的区别、相关套接字选项。
4. 简单对比多播 vs 广播，并且给出 Linux / Windows 实现差异的概览。

------

## 多播的基本概念

**多播（Multicast / 组播）**：

- 介于单播（一对一）和广播（一对所有）之间的一种**一对多**通信方式。
- 将“对同一种业务感兴趣的一组主机”逻辑分为一个 **多播组**。
- 发送端只发送一次数据包，由网络中的路由器复制并转发给该组中的所有成员。

典型用途：

- 实时音视频直播、一对多的在线课堂。
- 股票行情、多媒体分发等“一个源，很多接收者”的场景。

多播的几个关键特点（书里也差不多是这几条）：

1. **服务器只对某个多播组发送一次数据**。
2. **组内所有已加入该组的客户端都能收到这一次数据**。
3. 多播组是“逻辑概念”，在 IP 地址范围内可以有很多组。
4. 只有“加入该组”的主机才会收到对应数据；没加入的主机不会被打扰。

> 在实现上，本书的多播都是 **基于 UDP** 的：数据是标准 UDP 报文，只是目的地址换成了“多播 IP”。

------

## 多播地址与多播组

**IPv4 多播地址 = D 类地址段**：
`224.0.0.0 ~ 239.255.255.255`。

“加入多播组”可以理解为：

> “在 D 类地址中，我声明：我要接收发往 239.x.x.x 这个地址的多播数据包。”

在代码里，加入组是通过 `setsockopt` + `IP_ADD_MEMBERSHIP` 完成的，下文会说。

------

## 多播相关的套接字选项

这几个选项都在 **IP 层（IPPROTO_IP）** 上设置：

- `IP_MULTICAST_TTL`
- `IP_MULTICAST_IF`
- `IP_MULTICAST_LOOP`
- `IP_ADD_MEMBERSHIP`
- `IP_DROP_MEMBERSHIP`

### IP_MULTICAST_TTL

- **作用**：设置多播包的 **TTL（Time To Live, 生存时间）**，决定它最多能经过多少个路由器。
- **效果**：
    - 每经过一个路由器，TTL - 1。
    - TTL 变 0，包就被丢弃，不再继续转发。
    - 设置过大会让包在网络中跑得很远，可能造成不必要的流量；设置过小又可能到不了目标。
- **是否支持修改**：可以修改，一般发送端在创建 socket 后设置。
- **示例**：

```c
unsigned char ttl = 64; // 通常是 1、4、16、64 之类
if (setsockopt(sock, IPPROTO_IP, IP_MULTICAST_TTL,
               &ttl, sizeof(ttl)) < 0) {
    perror("setsockopt(IP_MULTICAST_TTL) error");
}
```

> 注意很多实现要求 `ttl` 用 `unsigned char`，别直接拿 `int` 乱传。

------

### IP_ADD_MEMBERSHIP / IP_DROP_MEMBERSHIP

- **作用**：加入 / 退出某个多播组。

- **使用的结构体**：`struct ip_mreq`（IPv4）。

    ```c
    struct ip_mreq {
        struct in_addr imr_multiaddr;  // 多播组地址
        struct in_addr imr_interface;  // 本机要用哪个本地 IP 加入（通常 INADDR_ANY）
    };
    ```

- **是否支持修改**：可以，通过 `setsockopt` 增删组成员。

- **加入组示例（接收端常用）**：

```c
int sock = socket(AF_INET, SOCK_DGRAM, 0);

struct sockaddr_in addr;
memset(&addr, 0, sizeof(addr));
addr.sin_family      = AF_INET;
addr.sin_addr.s_addr = htonl(INADDR_ANY);
addr.sin_port        = htons(9000);

// 允许多个进程/程序绑定同一端口（多播接收常用）
int reuse = 1;
setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
bind(sock, (struct sockaddr*)&addr, sizeof(addr));

struct ip_mreq mreq;
mreq.imr_multiaddr.s_addr = inet_addr("239.255.0.1");     // 组地址
mreq.imr_interface.s_addr = htonl(INADDR_ANY);            // 使用默认本地 IP

if (setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP,
               &mreq, sizeof(mreq)) < 0) {
    perror("setsockopt(IP_ADD_MEMBERSHIP) error");
}
```

- **退出组**：

```c
setsockopt(sock, IPPROTO_IP, IP_DROP_MEMBERSHIP,
           &mreq, sizeof(mreq));
```

------

### IP_MULTICAST_LOOP

- **作用**：控制多播数据是否“回环”到发送者本机。
    - 默认一般为 **开启（1）**：自己发送的多播包，本机也能从组里收到。
    - 设为 0：发送方不再收到自己的多播。
- **典型用途**：
    - 调试时：开回环，方便本机发本机收。
    - 实际业务：有时会关掉，避免收到自己发的内容。
- **示例**：

```c
unsigned char loop = 0; // 0 关闭回环，1 开启回环
setsockopt(sock, IPPROTO_IP, IP_MULTICAST_LOOP,
           &loop, sizeof(loop));
```

------

### IP_MULTICAST_IF

- **作用**：指定“从哪个网络接口发送多播包”。
- **典型场景**：
    - 机器有多块网卡（多 IP），希望多播只从某块网卡出去。
- **示例**：

```c
struct in_addr local_if;
local_if.s_addr = inet_addr("192.168.1.100"); // 某个本地网卡 IP
setsockopt(sock, IPPROTO_IP, IP_MULTICAST_IF,
           &local_if, sizeof(local_if));
```

------

## 多播发送端 & 接收端流程

### 多播发送端（基于 UDP）

典型流程：

1. `socket(AF_INET, SOCK_DGRAM, 0)` 创建 UDP 套接字。
2. 设置 `IP_MULTICAST_TTL`（视需要再设置 `IP_MULTICAST_IF`, `IP_MULTICAST_LOOP`）。
3. 构造 `sockaddr_in`，`sin_addr.s_addr = inet_addr("239.x.x.x")`，`sin_port = htons(port)`。
4. `sendto()` 把数据发往该多播地址 / 端口。

简化示例：

```c
int sock = socket(AF_INET, SOCK_DGRAM, 0);

unsigned char ttl = 16;
setsockopt(sock, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl));

struct sockaddr_in maddr;
memset(&maddr, 0, sizeof(maddr));
maddr.sin_family      = AF_INET;
maddr.sin_addr.s_addr = inet_addr("239.255.0.1");
maddr.sin_port        = htons(9000);

const char* msg = "hello multicast";
sendto(sock, msg, strlen(msg), 0,
       (struct sockaddr*)&maddr, sizeof(maddr));
```

------

### 多播接收端（基于 UDP）

典型流程：

1. `socket(AF_INET, SOCK_DGRAM, 0)`。
2. `setsockopt(SO_REUSEADDR)` 允许多个接收者在同一端口上绑定（可选但常用）。
3. `bind()` 到 `INADDR_ANY` + 多播端口。
4. 填好 `ip_mreq`，调用 `setsockopt(IP_ADD_MEMBERSHIP)` 加入组。
5. 循环 `recvfrom()` 即可收到发往该组的所有多播数据。

------

## 广播的基本概念

**广播（Broadcast）**：一个主机向所在网络内 **所有主机** 发送数据。

关键点：

1. TCP/IP 协议栈中，**只有 UDP 支持广播**。
2. 广播包一般 **不会跨路由器**（受限广播），因此只在本地广播域内有效。
3. 常见广播地址形式：
    - **受限广播地址（本地广播）**：`255.255.255.255`
        - 路由器不会转发，只在本地网络有效。
    - **直接广播地址（定向广播）**：网段的 IP 里主机位全 1，如 `192.168.1.255` 对应 `192.168.1.0/24` 网段。

常见用途：

- 局域网内的服务发现（例如某些游戏“局域网对战”）。
- ARP、DHCP 之类协议的某些阶段。

------

### 本地广播

- **地址写法**：`255.255.255.255`
- **含义**：
     “发给**我所在这个链路上的所有主机**，不经过任何路由器”。
- **特点**：
    1. **不会被路由器转发**
         路由器看到目的地址是 `255.255.255.255`，直接丢在本地链路上，**不会继续往别的网段转**。
    2. **只在发送端所在的子网内有效**
         也就是 A 在 `192.168.1.0/24`，这个广播包只会到这个网段里的机器。
    3. **典型使用场景**：
        - 主机还不知道自己 IP 时（DHCP Discover：`0.0.0.0 -> 255.255.255.255`）
        - 只想在“当前网段”吼一声，完全不关心别的网段。

------

### 直接广播

- **地址写法**：
     目标网络号 + 主机位全 1，例如：
    - 对于网段 `192.168.2.0/24`，**直接广播地址**是 `192.168.2.255`
    - 对于 `10.0.0.0/8`，广播地址是 `10.255.255.255`
- **含义**：
     “发给**某个特定网段里的所有主机**”。
- **特点**：
    1. **可以被路由**（理论上）
        - 发送端不一定在 `192.168.2.0/24` 这个网段上；
        - 路由器会把包转发到那个网段的出口接口；
        - 在那条目标网段上，把它以二层广播的形式（MAC: `ff:ff:ff:ff:ff:ff`）发出去。
    2. **作用范围：指定的那个远端子网**
         只要中间路由器允许“定向广播”，理论上可以从别的网段给这个子网里所有机器发广播。
    3. **现实里经常被关掉**
         由于以前有著名的 **Smurf 攻击**（利用定向广播做放大攻击），很多路由器/系统默认**禁止转发定向广播**，所以在现代网络上你很少真的用到这一招。

## UDP 广播编程与 SO_BROADCAST

要在程序里使用广播：

1. 创建 UDP socket：`socket(AF_INET, SOCK_DGRAM, 0)`。
2. 调用 `setsockopt` 打开广播权限：`SO_BROADCAST`。
3. 目标地址写成广播 IP（如 255.255.255.255 或 192.168.1.255）+ 端口。
4. 使用 `sendto()` 发送；接收方只需在对应端口上 `bind + recvfrom` 即可。

### SO_BROADCAST 选项说明

- **作用**：允许此 socket 发送广播报文。
- **是否支持修改**：可以，默认一般是关闭的；必须手动打开。
- **示例**：

```c
int sock = socket(AF_INET, SOCK_DGRAM, 0);

int on = 1;
if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST,
               &on, sizeof(on)) < 0) {
    perror("setsockopt(SO_BROADCAST) error");
}

struct sockaddr_in baddr;
memset(&baddr, 0, sizeof(baddr));
baddr.sin_family      = AF_INET;
baddr.sin_addr.s_addr = inet_addr("255.255.255.255");
baddr.sin_port        = htons(9000);

const char* msg = "hello broadcast";
sendto(sock, msg, strlen(msg), 0,
       (struct sockaddr*)&baddr, sizeof(baddr));
```

接收端只需：

```c
int sock = socket(AF_INET, SOCK_DGRAM, 0);

struct sockaddr_in addr;
memset(&addr, 0, sizeof(addr));
addr.sin_family      = AF_INET;
addr.sin_addr.s_addr = htonl(INADDR_ANY);
addr.sin_port        = htons(9000);

bind(sock, (struct sockaddr*)&addr, sizeof(addr));

char buf[1024];
ssize_t n = recvfrom(sock, buf, sizeof(buf), 0, NULL, NULL);
```

------

## 对比归纳

从网络范围 & 使用方式看：

- **目标对象**
    - 多播：一组**显式加入组**的主机（多播组）。
    - 广播：所在网络内**所有主机**，不管要不要。
- **可跨路由器？**
    - 多播：可以，依赖支持多播的路由器和 TTL 控制范围。
    - 广播：受限广播地址不会被路由器转发，通常仅限本地广播域；定向广播能否跨网段要看路由器设置。
- **地址类型**
    - 多播：D 类地址（224.0.0.0 ~ 239.255.255.255）。
    - 广播：某个网段的 host 部分全 1，如 `192.168.1.255`，或受限广播 `255.255.255.255`。
- **典型用途**
    - 多播：Internet/大网络的一对多分发（直播、多媒体）。
    - 广播：局域网内的服务发现、地址获取（DHCP）、各种“找一找附近设备”的场景。

------

## Windows 下的实现差异

本章最后会顺带给出 Windows 版的示例，核心差异：

- 使用 Winsock，需要：
    - 启动时 `WSAStartup(...)`
    - 程序结束时 `WSACleanup()`
- 关闭套接字是 `closesocket()` 而不是 `close()`。
- 多播/广播相关选项名基本一致：
    - `setsockopt(sock, IPPROTO_IP, IP_MULTICAST_TTL, ...)`
    - `setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, ...)`
    - `setsockopt(sock, SOL_SOCKET, SO_BROADCAST, ...)`

函数调用顺序、整体思路和 Linux 几乎一样，你已经能看懂 Linux 版代码的话，Windows 版只是在“开头和结尾多了两句初始化/清理”的程度。

------

## 代码

sender.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define BUF_SIZE 30
#define TTL 64

void error_handling(char* message);

int main(int argc, char* argv[]) {
    if (argc != 4) {
        printf("<IP> <Port> <Open Broadcast>\n");
        exit(1);
    }

    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock == -1) {
        error_handling("socket() error");
    }

    int time_live = TTL;
    setsockopt(sock, IPPROTO_IP, IP_MULTICAST_TTL, (void*)&time_live, sizeof(time_live));

    int open_broadcast = atoi(argv[3]);
    struct sockaddr_in address;
    memset(&address, 0, sizeof(address));
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = inet_addr(open_broadcast == 1 ? "255.255.255.255" : argv[1]);
    address.sin_port = htons(atoi(argv[2]));
    
    setsockopt(sock, SOL_SOCKET, SO_BROADCAST, (void*)&open_broadcast, sizeof(open_broadcast));

    FILE* fp = fopen("data.txt", "r");
    if (fp == NULL) {
        error_handling("fopen() error");
    }

    char buf[BUF_SIZE];
    while (fgets(buf, BUF_SIZE, fp) != NULL) {
        sendto(sock, buf, strlen(buf), 0, (struct sockaddr*)&address, sizeof(address));
        sleep(1);
    }

    fclose(fp);
    close(sock);

    return 0;
}

void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}

```

receiver.c

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#define BUF_SIZE 30

void error_handling(char* message);

int main(int argc, char* argv[]) {
    if (argc != 4) {
        printf("<IP> <Port> <Broadcast>\n");
        exit(1);
    }

    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock == -1) {
        error_handling("socket() error");
    }
    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    addr.sin_port = htons(atoi(argv[2]));

    if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
        error_handling("bind() error");
    }

    int open_broadcast = atoi(argv[3]);
    struct ip_mreq join_addr;
    memset(&join_addr, 0, sizeof(join_addr));
    join_addr.imr_multiaddr.s_addr = inet_addr(argv[1]);
    join_addr.imr_interface.s_addr = htonl(INADDR_ANY);
    if (open_broadcast != 1) {
        setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (void*)&join_addr, sizeof(join_addr));
    }

    char buf[BUF_SIZE];
    while (1) {
        int len = recvfrom(sock, buf, BUF_SIZE - 1, 0, NULL, 0);
        if (len < 0) {
            break;
        }
        buf[len] = '\0';
        fputs(buf, stdout);
        fflush(stdout);
    }
    close(sock);

    return 0;
}


void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}

```

## 本章小结

快速回顾第 14 章要点：

- 多播：基于 UDP 的“一发多收”机制，目标是“加入某个组的主机集合”，使用 D 类地址。
- 多播关键选项：
    - `IP_MULTICAST_TTL`：控制传输范围（路由跳数）。
    - `IP_ADD_MEMBERSHIP` / `IP_DROP_MEMBERSHIP`：加入/退出多播组，用 `struct ip_mreq`。
    - `IP_MULTICAST_LOOP`、`IP_MULTICAST_IF`：本机回环 & 选择出接口。
- 广播：在局域网内“一发给所有人”，主要是 UDP 广播。
    - 受限广播 `255.255.255.255`：只在本地网段，路由器不转发。
    - 直接广播：某网段 host 部分全 1 的地址，如 `192.168.1.255`。
    - 发送端必须打开 `SO_BROADCAST`。
- 多播 vs 广播：
    - 多播 = 分组广播（按组）；广播 = 对整个广播域喊话。
    - 多播可跨越更大网络范围，广播通常局限局域网。

