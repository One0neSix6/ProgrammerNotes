---
title: TCP/IP网络编程笔记10
date: 2025-12-12 10:17:10
categories: 网络编程
tags: TCP/IP网络编程
---

# 第十一章 & 第十二章

## 本篇整体定位

书名：**《TCP/IP 网络编程》（尹圣雨）**
 本篇涵盖：

- **第 11 章：进程间通信（IPC）**
- **第 12 章：I/O 复用（select）**

核心目标：

1. 理解什么是 **进程间通信**，为什么需要它。
2. 掌握基于 **管道 pipe** 的 IPC 基本用法。
3. 理解 **多进程服务器的代价**，为什么引入 I/O 复用。
4. 会用 **select + fd_set 宏** 写一个简单的多路复用 echo 服务器。

------

## 进程间通信（第 11 章）

### 进程间通信的基本概念

- 每个进程都有**独立的虚拟地址空间**，彼此不能直接访问。
- 但有时候不同进程需要交换数据 ⇒ 这就需要 **IPC（Inter-Process Communication）**。
- 操作系统提供一些“大家都能访问”的内存/内核对象，进程通过这些对象来通信。

本章主要用到的 IPC 手段：**管道（pipe）**。

------

### 匿名管道 pipe

#### 函数原型

```c
#include <unistd.h>

int pipe(int pipefd[2]);
// 成功返回 0，失败返回 -1
// pipefd[0]：读端（read）
// pipefd[1]：写端（write）
```

特点：

- 管道本质是 **内核里的一个缓冲区**，既不是普通文件，也不属于某个进程。
- `pipefd[0]` 只能读，`pipefd[1]` 只能写（约定俗成）。
- **半双工**：数据只沿着 “写端 → 读端” 单向流动。
- 常见用法：父进程 `pipe()` 之后 `fork()`，父子进程各拿一头进行通信。

#### 基本使用模型（父写子读）

典型步骤：

1. 父进程调用 `pipe(fds)` 得到两个 fd。
2. 调用 `fork()` 产生子进程。
3. 在父进程中：关闭 `fds[0]`（读端），只用 `fds[1]` 写。
4. 在子进程中：关闭 `fds[1]`（写端），只用 `fds[0]` 读。
5. 写入 / 读取数据。

简化示例：

```c
int fds[2];
pipe(fds);

pid_t pid = fork();
if (pid == 0) {  // 子进程：读
    close(fds[1]);            // 关闭写端
    char buf[100];
    int n = read(fds[0], buf, sizeof(buf) - 1);
    if (n > 0) {
        buf[n] = '\0';
        printf("child recv: %s\n", buf);
    }
} else {         // 父进程：写
    close(fds[0]);            // 关闭读端
    const char* msg = "hello pipe\n";
    write(fds[1], msg, strlen(msg));
}
```

#### 管道读写的一些语义（阻塞模式）

在默认阻塞 I/O 下：

- **读端行为**：
    - 管道有数据 → `read()` 读出数据并返回字节数。
    - 管道无数据、还有写端打开 → `read()` 阻塞等待。
    - 所有写端都关闭且数据读完 → `read()` 返回 **0**（类似读到文件结尾 EOF）。
- **写端行为**：
    - 管道未满 → `write()` 把数据写进去，返回字节数。
    - 管道已满、还有读端 → `write()` 阻塞，直到有空间。
    - 所有读端都关闭 → 再写会触发 `SIGPIPE`，`write()` 返回 -1，`errno = EPIPE`。

知道这些后，看书里的例子就容易很多：大部分 demo 都是 “父写子读”，利用这些语义实现简单通信。

------

### 双向通信：两个管道

因为单个管道只能**单向**通信，如果你想做到：

> 父进程给子进程发命令，子进程再回个响应，

就需要 **两个管道**：

- 管道 A：父写、子读。
- 管道 B：子写、父读。

示意代码：

```c
int p2c[2];  // parent -> child
int c2p[2];  // child -> parent
pipe(p2c);
pipe(c2p);

pid_t pid = fork();
if (pid == 0) {
    // 子进程
    close(p2c[1]);  // 关掉自己不用的写端
    close(c2p[0]);  // 关掉自己不用的读端

    char cmd[100];
    int n = read(p2c[0], cmd, sizeof(cmd));
    // ...处理...
    const char* resp = "OK\n";
    write(c2p[1], resp, strlen(resp));
} else {
    // 父进程
    close(p2c[0]);
    close(c2p[1]);

    const char* cmd = "do something\n";
    write(p2c[1], cmd, strlen(cmd));

    char resp[100];
    int n = read(c2p[0], resp, sizeof(resp));
    // ...处理 resp ...
}
```

这就是最简单的 **管道 IPC “请求-响应” 模式**，本章主要就是围绕这种模型展开各种小例子。

------

### 管道与网络编程的联系

本章虽然叫“进程间通信”，但它是在为后面章节打基础，尤其是：

- 你可以用**管道**做进程间通知，配合 `select()` 等 I/O 复用接口。
- 后面讲 I/O 流分离、多进程服务器时，会把“**管道 fd 也是普通 fd**”这个特性用得很多。
- 重要思想：**文件描述符统一抽象** —— 不管是文件、socket 还是管道，在 Linux 里都可以通过 `read` / `write` / `select` 等统一操作。

------

## I/O 复用：select（第 12 章）

### 为什么需要 I/O 复用

上一章的多进程服务器模型：

- 每来一个客户端连接就 `fork()`。
- 每个子进程只管一个客户端。

问题：

- **创建/销毁进程开销大**：复制页表、分配资源、上下文切换。
- 每个进程有独立地址空间，**进程间通信复杂**（需要 pipe / 共享内存 / 消息队列）。
- 很多时候客户端是“偶尔发一条消息”，子进程大部分时间都在阻塞 `read()`，实际 CPU 利用率并不高。

I/O 复用的想法：

> 用 **一个进程**，同时“盯着”多个 socket，看哪一个准备好了就在哪一个上面收发数据。

Linux 中最经典的 I/O 复用接口就是 **`select()`**，本章重点就是把它吃透。

------

### select 函数原型与含义

#### 函数原型

```c
#include <sys/select.h>
#include <sys/time.h>

int select(int nfds,
           fd_set* readfds,
           fd_set* writefds,
           fd_set* exceptfds,
           struct timeval* timeout);
```

参数含义（重点）：

- `nfds`
    - 监控的 **最大文件描述符 + 1**。
    - 一般写成 `fd_max + 1`。
- `readfds`
    - 想要监控“**读就绪**”的 fd 集合，比如：监听 socket、客户端 socket。
- `writefds`
    - 想要监控“**写就绪**”的 fd 集合（比如发送缓冲区不满时）。
    - 初学时经常传 `NULL`。
- `exceptfds`
    - 监控异常条件（带外数据等），入门阶段常用 `NULL`。
- `timeout`
    - 超时控制：
        - `NULL`：一直阻塞，直到有 fd 就绪。
        - `0 秒 + 0 微秒`：立即返回，变成“轮询”（非阻塞检查）。
        - 其他值：最多等待这么久，如果期间没有任何 fd 就绪，返回 0。

返回值：

- `> 0`：就绪的 fd 数量。
- `== 0`：超时。
- `< 0`：出错（`errno` 中有错误码）。

**非常重要的一点**：
 `select()` 会 **修改** 你传入的 `fd_set`，只保留就绪的那几个 fd，所以一般会：

1. 准备一个“**原始集合**” `reads`，长期维护。
2. 每次调用 `select()` 前，先 `cpy_reads = reads;`。
3. 把 `&cpy_reads` 传给 `select()`。

------

### fd_set 与四个宏

`fd_set` 是一个位图结构，用来表示“一个 fd 是否被关注”。

常用宏：

```c
FD_ZERO(fd_set *set);           // 清空集合
FD_SET(int fd, fd_set *set);    // 把 fd 加入集合
FD_CLR(int fd, fd_set *set);    // 把 fd 从集合中移除
FD_ISSET(int fd, fd_set *set);  // 判断 fd 是否在集合中（且就绪）
```

典型使用流程（读事件）：

```c
fd_set reads, cpy_reads;
FD_ZERO(&reads);
FD_SET(server_sock, &reads);
int fd_max = server_sock;

while (1) {
    cpy_reads = reads;  // 一定要拷贝
    struct timeval timeout;
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;

    int fd_num = select(fd_max + 1, &cpy_reads, NULL, NULL, &timeout);
    if (fd_num == -1) continue;
    if (fd_num == 0) continue; // 超时，可做心跳等

    for (int fd = 0; fd <= fd_max; fd++) {
        if (FD_ISSET(fd, &cpy_reads)) {
            // 这个 fd 上有事件
        }
    }
}
```

------

### 基于 select 的多路复用 echo 服务器结构

整体思路：

1. 创建监听 socket：`socket → bind → listen`。
2. 准备 `fd_set reads`，把 `server_sock` 加进去。
3. `while(1)` 循环里：
    - 复制 `reads` → `cpy_reads`。
    - `select(fd_max + 1, &cpy_reads, NULL, NULL, &timeout)`。
    - 遍历所有 fd：
        - 如果是 `server_sock` 就绪 → `accept()` 新客户端，再把新 `client_sock` 加入 `reads`，更新 `fd_max`。
        - 如果是某个 `client_sock` 就绪 → `read()` 数据：
            - `read_cnt > 0`：处理并 `write()` 回去（echo）。
            - `read_cnt == 0`：对端关闭连接，`close()`，并且 `FD_CLR` 把它从 `reads` 集合中移除。

伪代码：

```c
int server_sock = socket(...);
bind(...);
listen(...);

fd_set reads, cpy_reads;
FD_ZERO(&reads);
FD_SET(server_sock, &reads);
int fd_max = server_sock;

while (1) {
    cpy_reads = reads;
    struct timeval timeout = {5, 0};

    int fd_num = select(fd_max + 1, &cpy_reads, NULL, NULL, &timeout);
    if (fd_num <= 0) continue;

    for (int fd = 0; fd <= fd_max; fd++) {
        if (!FD_ISSET(fd, &cpy_reads)) continue;

        if (fd == server_sock) {
            // 新连接
            struct sockaddr_in clnt_addr;
            socklen_t clnt_sz = sizeof(clnt_addr);
            int clnt_sock = accept(server_sock, (struct sockaddr*)&clnt_addr, &clnt_sz);
            FD_SET(clnt_sock, &reads);
            if (clnt_sock > fd_max) fd_max = clnt_sock;
        } else {
            // 客户端数据
            char buf[1024];
            int str_len = read(fd, buf, sizeof(buf));
            if (str_len <= 0) {               // 连接关闭或出错
                close(fd);
                FD_CLR(fd, &reads);
            } else {
                write(fd, buf, str_len);      // echo
            }
        }
    }
}
```

这就是典型的 **单进程 + select 并发 echo 服务器**，本章的示例代码就是类似这个结构。([CSDN](https://blog.csdn.net/m0_53115174/article/details/139277691?utm_source=chatgpt.com))

------

### I/O 复用与阻塞 / 非阻塞的关系

容易混的点：

- `select()` **本身是一个阻塞调用**（除非你设置 0 超时）。
- 但它可以在 **一个阻塞点上，等待多个 fd** 的就绪事件。
- 被 `select()` 判定为“可读”的 fd，接下来再 `read()` 时，一般不会阻塞（至少有一个字节可读）。

后面章节会再结合：

- **非阻塞 I/O（`O_NONBLOCK`）**
- **epoll**（第 17 章）

一起讨论高性能服务器的 I/O 模型。

------

## 代码

echo_select_server.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <sys/time.h>

#define BUF_SIZE 30

void error_handling(char* message);

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("port is null\n");
        exit(1);
    }
    int server_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (server_sock == -1) {
        error_handling("socket() error");
    }

    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(atoi(argv[1]));

    if (bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        error_handling("bind() error");
    }

    if (listen(server_sock, 5) == -1) {
        error_handling("listen() error");
    }

    fd_set fd_reads, cpy_reads;
    FD_ZERO(&fd_reads);
    FD_SET(server_sock, &fd_reads);
    int fd_max = server_sock;
    struct timeval timeout;

    int client_sock;
    char buf[BUF_SIZE];

    while (1) {
        cpy_reads = fd_reads;
        timeout.tv_sec = 5;
        timeout.tv_usec = 5000;

        int res = select(fd_max + 1, &cpy_reads, 0, 0, &timeout);
        if (res == -1) {
            error_handling("select() error");
        } else if (res == 0) {
            printf("time out\n");
            continue;
        } else {
            for (int i = 0; i <= fd_max; i++) {
                if (FD_ISSET(i, &cpy_reads)) {
                    if (i == server_sock) {
                        client_sock = accept(server_sock, NULL, NULL);
                        if (client_sock == -1) {
                            error_handling("accept() error");
                        }
                        if (client_sock > fd_max) {
                            fd_max = client_sock;
                        }
                        FD_SET(client_sock, &fd_reads);
                        printf("client connect, sock:%d\n", client_sock);
                    } else {
                        int len = read(i, buf, BUF_SIZE - 1);
                        if (len < 0) {
                            printf("read() error");
                        } else if (len == 0) {
                            FD_CLR(i, &fd_reads);
                            close(i);
                            printf("client close, sock:%d\n", i);
                            continue;
                        } else {
                            buf[len] = '\0';
                            printf("message from client %d, content: %s\n", i, buf);
                            write(i, buf, len);
                        }
                    }
                }
            }
        }
    }
    close(server_sock);

    return 0;
}

void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}
```

## 小结

**第 11 章：进程间通信**

- 进程有独立地址空间，想通信必须借助 **内核提供的共享资源**。
- 本章重点是 **匿名管道 `pipe()`**：
    - `pipefd[0]` 读、`pipefd[1]` 写，半双工。
    - `fork()` 后父子进程各持一端实现通信。
    - 管道本质是“内核里的缓冲区 + 一对 fd”，同样可以用 `read` / `write` 操作。
- 可以用 **两个管道** 模拟全双工父子通信（A→B 一条，B→A 一条）。

**第 12 章：I/O 复用**

- 多进程服务器虽然简单，但有进程创建、内存、上下文切换等开销。
- I/O 复用的目标：**一个进程同时管理多个 socket**。
- 本章主角：`select()` + `fd_set` 四兄弟（`FD_ZERO` / `FD_SET` / `FD_CLR` / `FD_ISSET`）。
- 典型模式：
    - 把所有关注的 fd 丢到 `fd_set` 里；
    - 调 `select()` 阻塞等待；
    - 返回后遍历 `fd_set` 判断哪些 fd 就绪再分别处理。
- 基于 `select()` 的 echo 服务器，是后面各种高性能网络模型的第一块积木。

