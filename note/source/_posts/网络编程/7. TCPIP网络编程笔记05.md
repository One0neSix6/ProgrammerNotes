---
title: TCP/IP网络编程笔记05
date: 2025-12-08 20:04:20
categories: 网络编程
tags: TCP/IP网络编程
---

# 第五章

## 本章整体定位

书名：**《TCP/IP 网络编程》（尹圣雨）**
 第 5 章标题：**基于 TCP 的服务器端/客户端（2）**

主要内容：

1. 解决第 4 章中 **回声客户端（echo client）的缺陷**，给出“更完美”的实现
2. 引出一个重要结论：**TCP 是“字节流”，应用层必须自己定义数据边界（应用层协议）**
3. 用“计算器服务器端/客户端”示例，演示如何设计简单的应用层协议
4. 进一步讲解 **TCP 的内部工作原理**：
    - 套接字内的 I/O 缓冲（发送缓冲区 / 接收缓冲区）
    - 三次握手（连接建立）
    - 数据交换过程
    - 四次挥手（连接终止）
5. 补充下 **Windows 平台** 的实现差异（Winsock 调用几乎一致）

------

## 回声客户端的问题与“完美实现”

### 1. 回顾第 4 章的 echo 客户端问题

第 4 章的客户端核心逻辑大概是这样的：

```c
// 简化版逻辑
write(sock, message, strlen(message));           // 把一行数据发给服务器
str_len = read(sock, message, BUFF_SIZE - 1);    // 只读一次
```

而服务器端是：

```c
// 服务器端是“正确的”循环读写
while ((str_len = read(clnt_sock, message, BUFF_SIZE)) != 0) {
    write(clnt_sock, message, str_len);
}
```

理论上看起来没问题：服务器收到多少就回多少，客户端写一段数据、读一段数据。

**真正的问题在于：TCP 是“字节流”，一次 `read` 不保证收完一整条“消息”。**

- 即使服务器已经把所有 echo 数据写进了发送缓冲区，**网络传输 + 对端缓冲** 可能导致：
    - 第一次 `read` 只读到部分字节；
    - 甚至一次 `read` 读到多条消息的拼接。
- 但第 4 章的客户端只 `read` 一次，就假设“收到的就是完整一条消息”，这是**不安全的写法**。

在书中的例子里之所以“看起来没出问题”，只是因为测试数据短、环境简单，**问题被掩盖了**。

> 核心结论：**在 TCP 中，“一次 write 对应一次 read”是错误的想法。TCP 不保证“消息边界”。**

------

### 2. 为什么要按照“长度”循环读取？

假设我们只想实现“简单 echo”，可以借用一个“已知长度”的信息：

- 客户端每次写入 `len = strlen(message)` 字节到 socket；
- 那么：**只要把返回的 echo 数据累计读满 `len` 字节，就可以认为这一轮 echo 完成。**

伪代码：

```c
int to_send = strlen(message);
write(sock, message, to_send);

int received = 0;
while (received < to_send) {
    int n = read(sock, &message[received], BUFF_SIZE - 1 - received);
    if (n <= 0) error...;
    received += n;
}
```

这就是书中“更完美的 echo 客户端”的核心思想。

------

### 3. 通用的“读满 N 字节”函数：readn

更通用的做法是封装一个 `readn` 函数：

> **readn(fd, buf, len)：要么读满 len 字节，要么出错/对端关闭。**

```c
ssize_t readn(int fd, void* buf, size_t len) {
    size_t total = 0;
    char* p = (char*)buf;

    while (total < len) {
        ssize_t n = read(fd, p + total, len - total);
        if (n < 0) {
            // 被信号中断可以重试，这里简单处理
            return -1;
        } else if (n == 0) {
            // 对端关闭，返回目前已读的字节数
            break;
        }
        total += n;
    }
    return (ssize_t)total;
}
```

**特点：**

- 适用于“对方一定会发送固定长度数据”的场景（如 echo、计算器协议中的固定字段）。
- 若对端中途关闭连接，可能会读到部分数据再返回。

在 echo 客户端中，可以写成：

```c
int to_send = strlen(message);
write(sock, message, to_send);
int n = readn(sock, message, to_send);
```

------

### 4. 解决 echo 客户端问题的小结

1. 问题的根源不在服务器端，而在客户端错误地假设“一个 `read` 就足够”。
2. **TCP 是流式协议**：
    - 没有任何“报文边界”的概念；
    - 应用层自己负责把连续的字节切分成一条条消息。
3. echo 的简易做法：
    - 以“发送字节数”为准，循环读取，读满为止；
    - 或者干脆定义一套明确的“消息格式”。

这就顺势引出了下一节：**应用层协议**。

------

## 定义应用层协议：以计算器示例为代表

书中的“计算器服务器端/客户端”示例，本质是在做一件事：

> **不要再写“随便发一串字节”的协议，而是明确每个字段的长度、类型和语义。**

### 1. 一个简化版的“计算器协议”设计

示例的典型设计是这样的（简化版）：

客户端发送给服务器的数据格式：

1. **操作数个数**：1 字节（比如 `operand_count`）
2. **操作数列表**：每个操作数 4 字节（int，网络字节序），共 `operand_count * 4` 字节
3. **运算符**：1 字节（如 `+`, `-`, `*`）

总长度 = 1 + 4 * N + 1 字节。

服务器的行为：

1. 首先 `readn` 读取 1 字节得到 `operand_count`
2. 再读取 `operand_count * 4` 字节得到所有操作数
3. 再读取 1 字节得到运算符
4. 进行运算，将结果（通常 4 字节 int）通过 `write` 返回给客户端

客户端再用 `readn` 收到结果，打印即可。

> 注意：
>
> - 多字节整数要用 `htonl/ntohl` 处理，保证大小端一致。
> - **协议是双方约定好的“字节布局+含义”**，谁都不能随便改。

------

### 2. 应用层协议的价值

对比一下：

- 没有协议时：
    - 你只是在发送“一串没有解释的字节”；
    - 对端完全不知道这些字节如何拆分、如何解析。
- 有协议时：
    - 每条消息都有“固定格式”或“带长度的变长格式”；
    - 对端能严格按照格式逐字段读取和解析；
    - 协议一旦固定，就可以有多个不同实现互相通信（跨语言、跨平台）。

**直播 / 播放器 / 推流 / 信令等协议，本质上都是“更复杂的应用层协议”。**

本章借“计算器”这个玩具例子，让你习惯这种“先设计协议，再写代码”的思路。

------

## TCP 套接字中的 I/O 缓冲

这一节是对“write/read 到底在干什么”的更深入剖析。

### 1. I/O 缓冲在什么地方？

对于每个 TCP 套接字，内核都会为它分配两块缓冲区：

1. **发送缓冲区（send buffer）**
    - 应用层调用 `write` / `send` 时：
        - 数据首先被拷贝到这个缓冲区中；
        - 然后由内核按照 TCP 协议分片、加头、重传控制等，通过网卡发出去。
2. **接收缓冲区（recv buffer）**
    - 从网络上收到的 TCP 报文，会由内核校验、重组、排好顺序后，放到这个缓冲区；
    - 应用层调用 `read` / `recv` 时，**只是把数据从接收缓冲区拷贝到用户缓冲区**。

**重要特性：**

- 这两个缓冲区**不需要也不能由应用层直接管理**：
    - 套接字创建时自动分配；
    - 套接字关闭时自动释放；
- 它们的存在使得：
    - 发送和接收操作可以在应用程序与内核之间“解耦”；
    - 有利于滑动窗口、流量控制、延迟 ACK 等 TCP 机制的实现。

------

### 2. write / read 在 TCP 上的真实动作

结合缓冲区，可以这样理解：

- `write(sock, buf, len)`：
    - **只是把用户缓冲区的 len 字节拷贝到“发送缓冲区”**，通常很快返回；
    - 真正的网络发送（分片、重传、拥塞控制）由内核慢慢做；
    - 如果发送缓冲区已满，阻塞套接字会在 `write` 上阻塞，非阻塞会返回 `EAGAIN`。
- `read(sock, buf, len)`：
    - 如果接收缓冲区有数据，立即拷贝最多 `len` 字节到用户缓冲区，并返回实际字节数；
    - 如果缓冲区为空：
        - 阻塞套接字：等待数据到来；
        - 非阻塞：直接返回 `EAGAIN`。

因此：

> **TCP 的“可靠性、有序性”是在 I/O 缓冲 + TCP 协议栈内部完成的，应用层只看到一个“看起来很普通的字节流”。**

------

## 三次握手：建立 TCP 连接

书中在本章给出了 TCP 的三次握手（Three-way Handshake）过程。

简单描述（用 A 表示客户端，B 表示服务器）：

1. **第一次：A → B，SYN**
    - A 发送一个带 `SYN` 标志的报文段；
    - 报文里包含 A 的初始序列号 `seq = x`；
    - 表示：“我想和你建立连接，这是我数据序号的起点。”
2. **第二次：B → A，SYN + ACK**
    - B 收到 SYN，同意建立连接；
    - 回一个同时带 `SYN` 和 `ACK` 的报文；
    - `seq = y`（B 的初始序列号），`ack = x + 1`（确认收到了 A 的 SYN）。
3. **第三次：A → B，ACK**
    - A 收到 B 的 SYN+ACK；
    - 回一个仅带 `ACK` 的报文，`ack = y + 1`；
    - 至此，双方都确认对方的初始序列号，连接建立完成。

在应用层的表现就是：

- 客户端调用 `connect` 后，阻塞等待这一套三次握手完成；
- 服务端在 `listen` 之后，`accept` 会在握手完成后返回一个新的连接套接字。

------

## TCP 数据交换过程（滑动窗口的直观理解）

数据传输阶段可以简化理解为：

1. 发送方不断从自己的 **发送缓冲区** 中取数据，打包成一个个 TCP 报文发送；
2. 接收方收到报文后，先放入自己的 **接收缓冲区**；
3. 接收方会根据收到的数据序号、长度给发送方回 ACK，告知“已成功收到哪些字节”；
4. 发送方维护一个 **发送窗口**：
    - 已确认的数据可以从发送缓冲区“滑过去”并被释放；
    - 窗口内未确认数据如果超时没有收到 ACK，就会重传。

你不需要立刻掌握所有细节，但要建立几条直觉：

- 在应用层看不到“一个一个 TCP 包”，只看到：**多少字节已经“成功写入 / 读出”**；
- 当网络状况变差时：
    - RTT（往返时延）变大，重传次数增加；
    - 发送窗口可能缩小；
    - 应用层感受到的是：`write` 更慢、`read` 更慢，整体吞吐量下降。

------

## 四次挥手：断开 TCP 连接

断开连接的过程可以理解为“**双方各自发出 FIN，分别关闭发送方向**”。

仍然用 A（客户端）、B（服务器）来说明：

1. **A → B：FIN**
    - A 调用 `close`，内核先发送一个带 FIN 的报文；
    - 表示：“我这边不再给你发数据了，但还能收你发来的数据。”
2. **B → A：ACK**
    - B 收到 FIN，回一个 ACK；
    - 此时从 A 的角度看：**本方的发送通道关闭，但接收还开着**。
3. **B → A：FIN**
    - 当 B 也不再需要发送数据时，发送一个 FIN 报文给 A；
    - 表示：“我也发完了。”
4. **A → B：ACK**
    - A 收到 B 的 FIN，回一个 ACK；
    - 之后，双方的连接真正进入关闭状态。

在抓包中，有时你会看到：

- **FIN 和 ACK 合并在同一个报文里**（`[FIN, ACK]`），看起来像“3 个包就搞定”，但逻辑上仍然是“四次挥手”（四个动作）。

------

## Windows 实现（Winsock 部分）

本章最后照例补充了 Windows 平台下的实现差异，主要就是：

1. 使用 Winsock 之前必须初始化：

    ```c
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        // error
    }
    ```

2. 使用完毕需要清理：

    ```c
    WSACleanup();
    ```

3. 关闭套接字使用：

    ```c
    closesocket(sock);
    ```

4. 其它函数几乎与 Linux/BSD 版相同：

    - `socket / bind / listen / accept / connect / send / recv`
    - I/O 缓冲、三次握手、四次挥手的概念完全一致，只是 API 来自 WinSock 库。

> 总体可以理解为：
>  **Windows 只是多了“初始化 Winsock + closesocket”这套仪式感，其余逻辑和本章讲的 TCP 原理是共通的。**

------

## 本章知识点小结

快速回顾第 5 章，你可以记住这几条：

1. **echo 客户端的问题来自“把 TCP 当成有边界的消息协议”**：
    - 单次 `read` 不保证读满一次 `write` 的数据；
    - 更完美的客户端要么循环读取，读满已知长度，要么使用明确的应用层协议。
2. **应用层协议的重要性**：
    - 必须在“字节流”之上定义消息格式（字段顺序、长度、含义）；
    - 计算器例子是一个简单的二进制协议：操作数个数 + 操作数 + 运算符。
3. **I/O 缓冲的概念**：
    - 每个 TCP 套接字内部有发送缓冲区和接收缓冲区；
    - `write`/`read` 只是用户缓冲区和这些内核缓冲区之间的数据移动。
4. **三次握手**：
    - 通过 SYN / SYN+ACK / ACK 三步，双方交换初始序列号，建立可靠连接。
5. **数据交换与滑动窗口**：
    - TCP 通过 ACK、序列号和滑动窗口机制保证数据可靠、有序到达。
6. **四次挥手**：
    - 双方分别发送 FIN 并确认，实现全双工连接的“半关闭 → 完全关闭”。
7. **跨平台实现**：
    - Windows 与 Linux 的套接字调用顺序相同，只是多了 `WSAStartup/WSACleanup` 和 `closesocket`。

------

## 代码

### echo_client2.c —— 改进版回声客户端（读满发送长度）

下面是一个基于第 4 章 echo_client 改造的“更完美”的客户端示例：

- 每次发送一行数据给服务器；
- 根据发送的字节数，循环 `read`，直到收满为止。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define BUFF_SIZE 1024

void error_handling(const char* message);

/* 读满 len 字节，除非出错或对端关闭 */
ssize_t readn(int fd, void *buf, size_t len) {
    size_t total = 0;
    char *p = (char*)buf;

    while (total < len) {
        ssize_t n = read(fd, p + total, len - total);
        if (n < 0) {
            return -1;          // 出错
        } else if (n == 0) {
            break;              // 对端关闭
        }
        total += n;
    }
    return (ssize_t)total;
}

int main(int argc, char* argv[]) {
    int sock;
    char send_buf[BUFF_SIZE];
    char recv_buf[BUFF_SIZE];
    struct sockaddr_in server_addr;

    if (argc != 3) {
        printf("Usage: %s <IP> <port>\n", argv[0]);
        exit(1);
    }

    sock = socket(PF_INET, SOCK_STREAM, 0);
    if (sock == -1) {
        error_handling("socket() error");
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family      = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(argv[1]);
    server_addr.sin_port        = htons(atoi(argv[2]));

    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        error_handling("connect() error");
    }

    while (1) {
        fputs("Input message (Q to quit): ", stdout);
        if (!fgets(send_buf, BUFF_SIZE, stdin)) {
            break;  // EOF
        }

        if (!strcmp(send_buf, "q\n") || !strcmp(send_buf, "Q\n")) {
            break;
        }

        size_t to_send = strlen(send_buf);
        ssize_t sent = write(sock, send_buf, to_send);
        if (sent != (ssize_t)to_send) {
            error_handling("write() error or partial write");
        }

        // 从服务器读回同样长度的数据
        ssize_t received = readn(sock, recv_buf, to_send);
        if (received <= 0) {
            // <=0 表示出错或服务器关闭
            printf("server closed or read error\n");
            break;
        }

        // 补上字符串结束符
        if (received < BUFF_SIZE) {
            recv_buf[received] = '\0';
        } else {
            recv_buf[BUFF_SIZE - 1] = '\0';
        }

        printf("Message from server: %s", recv_buf);
    }

    close(sock);
    return 0;
}

void error_handling(const char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}
```

> 说明：
>
> 1. 和第 4 章的客户端相比，最大区别在于：
>     - 不再假设“一次 read 就够”；
>     - 使用 `readn` 按“发送长度”循环读。
> 2. 这是本章的核心思想之一：**不要相信 TCP 会帮你维护消息边界，应用层必须自己控制读取逻辑或定义协议。**