---
title: TCP/IP网络编程笔记13
date: 2025-12-14 15:18:15
categories: 网络编程
tags: TCP/IP网络编程
---

------

# 第十五章

------

## 整体定位

书名：**《TCP/IP 网络编程》（尹圣雨）**
第 15 章标题大意：**标准 I/O 函数与套接字**

前面一直用的是：

- 低级 I/O：`read` / `write`（面向文件描述符 `int fd`）

本章开始把 **C 标准 I/O 库（`stdio.h` 里的那些）** 拉进来，主要是：

- 用 `FILE*` 做缓冲 I/O（`fopen` / `fgets` / `fputs` 等）
- 以及：怎样在 **套接字** 上使用这些标准 I/O（`fdopen` / `fileno`）

- 文件流相关：`fopen`, `feof`, `fputs`, `fputc`, `fgetc`, `fgets`
- fd ↔ FILE* 互转：`fdopen`, `fileno`

------

## 标准 I/O 与底层 I/O 的区别

- **底层 I/O**：`read(int fd, void *buf, size_t)` / `write(int fd, const void *buf, size_t)`
    - 面向「字节 + 文件描述符」
    - 内核级缓冲
    - 没有额外格式/行概念
- **标准 I/O**：`FILE*` + `fread/fwrite/fgets/fputs` 等
    - 在底层 I/O 上 **再加一层用户态缓冲（C 库缓冲）**
    - 支持按行读（`fgets`）、按字符读（`fgetc`）、按格式读写（`fprintf` / `fscanf`）
    - 读写效率高一点，写文本更方便

网络编程里，两者**都能用**。

------

## fopen

### 原型

```c
#include <stdio.h>

FILE* fopen(const char* pathname, const char* mode);
```

### 参数

- `pathname`：文件路径，例如 `"data.txt"`、`"/tmp/log.txt"`。
- `mode`：打开模式（字符串）：
    - `"r"`：只读（必须文件已存在）
    - `"w"`：只写（不存在则创建，存在则截断）
    - `"a"`：追加写（不存在则创建）
    - `"r+"`：读写，文件必须存在
    - `"w+"`：读写，先清空
    - `"a+"`：读写，写在末尾
    - 后缀 `"b"` 表示二进制模式（Windows 上有区别：`"rb"`, `"wb"`）。

### 返回值

- 成功：返回一个 `FILE*` 指针。
- 失败：返回 `NULL`，可通过 `perror` 或 `strerror(errno)` 看错误原因。

### 小示例

```c
FILE *fp = fopen("data.txt", "r");
if (fp == NULL) {
    perror("fopen error");
    exit(1);
}
```

------

## feof

### 原型

```c
#include <stdio.h>

int feof(FILE* stream);
```

### 作用

- 判断 `FILE*` 是否 **已经读到文件末尾**。
- 返回：
    - 非 0：已经到 EOF
    - 0：尚未到 EOF

### 重点坑：**不能用 `while (!feof(fp))` 来读文件**

```c
while (!feof(fp)) {
    fgets(buf, sizeof buf, fp);
    ...
}
```

原因：

- `feof(fp)` 只有在你 **尝试读取、且读失败/超出末尾之后** 才会置位。
- 通俗说：**你得先多读一次，才会知道“已经到头了”**。
- 正确写法应该是：**用读函数的返回值作为循环条件**，比如：

```c
while (fgets(buf, sizeof buf, fp) != NULL) {
    ...
}
```

或者：

```c
size_t n;
while ((n = fread(buf, 1, sizeof buf, fp)) > 0) {
    ...
}
```

`feof` 比较常用的姿势是：在出错时区分“是 EOF 还是 read error”：

```c
if (fgets(buf, sizeof buf, fp) == NULL) {
    if (feof(fp)) {
        puts("EOF reached");
    } else {
        perror("read error");
    }
}
```

------

## fputs

### 原型

```c
#include <stdio.h>

int fputs(const char* s, FILE* stream);
```

### 作用

- 把以 `'\0'` 结尾的 C 字符串写到指定的 `FILE*` 中。
- **不会自动加换行**，你传的字符串里有啥就写啥。

### 返回值

- 成功：非负值（通常是最后一个字符的 `unsigned char` 值）。
- 失败：`EOF`（即 `-1`），可以再用 `ferror(stream)` 判断是否出错。

### 示例

```c
FILE* fp = fopen("out.txt", "w");
if (!fp) perror("fopen");

fputs("hello\n", fp);
fputs("world\n", fp);

fclose(fp);
```

如果是写到标准输出：

```c
fputs("message from server\n", stdout);
```

**注意结合缓冲行为**：

- stdout 连接终端：行缓冲（遇到 `\n` 一般自动 flush）
- stdout 重定向到文件 / 管道：可能变成全缓冲，要靠 `fflush(stdout)` 或 `fclose` 才真正写出去。

------

## fputc

### 原型

```c
#include <stdio.h>

int fputc(int c, FILE* stream);
```

### 作用

- 向 `stream` 写入一个字符 `c`（会转换成 `unsigned char`）。
- 比 `fputs` 更底层一点，一次一个字符。

### 返回值

- 成功：写入的字符（以 `unsigned char` 提升为 `int`）。
- 失败：返回 `EOF`。

### 示例

```c
fputc('H', stdout);
fputc('\n', stdout);
```

很多错误处理函数里都这样写：

```c
void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}
```

这就是你书里反复出现的写法：

- 用 `fputs` 打印错误字符串
- 用 `fputc('\n', stderr)` 补一个换行
- 最后 `exit(1)` 退出程序

------

## fgetc

### 原型

```c
#include <stdio.h>

int fgetc(FILE *stream);
```

### 作用

- 从 `stream` 读取一个字符，返回值用 `int` 表示。

### 返回值（非常重要）

- 成功：返回 `0~255` 范围内的字符（转成 `unsigned char` 再提升为 `int`）。
- 失败或 EOF：返回 **`EOF`（通常是 -1）**。

**坑点**：
因为会返回 `EOF`，所以要用 `int` 接收，不能直接用 `char`，否则你没法区分“读到了字节 0xFF”还是“EOF”。

正确写法：

```c
int ch;
while ((ch = fgetc(fp)) != EOF) {
    putchar(ch);
}
```

------

## fgets

### 原型

```c
#include <stdio.h>

char* fgets(char* s, int n, FILE* stream);
```

### 作用

从 `stream` 中读取 **最多 n-1 个字符**，并在末尾自动加 `'\0'`。

- 遇到以下任一情况就停止：
    1. 读到 `n-1` 个字符；
    2. 读到一个换行 `\n`（也会被放入缓冲）；
    3. 遇到 EOF 或出错。

### 返回值

- 成功：返回 `s`（也就是传入的缓冲区指针）。
- 失败 / 立刻遇 EOF：返回 `NULL`。

### 特点

- **会保留换行符**，如果缓冲区足够大，读到的字符串通常是形如 `"hello\n\0"`。
- 循环读文本文件/文本 socket 时非常好用。

典型模式（正确）：

```c
char buf[1024];
while (fgets(buf, sizeof buf, fp) != NULL) {
    printf("line: %s", buf);  // buf 里已经有 '\n' 的话不用再加
}
```

------

## fdopen 和 fileno

标准 I/O 用的是 `FILE*`；
socket API 用的是 `int fd`。

这两个函数就是 **在这两种世界之间架桥**。

------

### fdopen

#### 原型

```c
#include <stdio.h>

FILE* fdopen(int fd, const char* mode);
```

#### 作用

- 已经有一个文件描述符（比如：
    - `open()` 打开的文件 fd，
    - 或者 `accept()` 得到的 socket fd），
- 想要对它使用 `fgets` / `fputs` / `fprintf` 这类标准 I/O 函数，
- 就可以用 `fdopen` 把这个 fd **包装**成一个 `FILE*`。

#### 参数

- `fd`：已经存在的文件描述符（如 socket）。
- `mode`：和 `fopen` 的 mode 一样：
    - 比如 `"r"`、`"w"`、`"r+"`、`"w+"` 等；
    - 一定要和 fd 的实际权限匹配（只读/只写/读写），否则 UB。

#### 返回值

- 成功：一个 `FILE*`，后面就像普通文件那样用。
- 失败：`NULL`。

```c
int clnt_sock = accept(serv_sock, ...);

// 把 socket 封成读写流
FILE* readfp  = fdopen(clnt_sock, "r");
FILE* writefp = fdopen(dup(clnt_sock), "w"); // 用 dup 分一个 fd 出来更保险

char buf[BUFSIZ];

// 从 socket 读一行
while (fgets(buf, sizeof buf, readfp) != NULL) {
    printf("from client: %s", buf);
    fputs(buf, writefp);  // echo 回去
    fflush(writefp);      // 记得刷新
}
fclose(readfp);
fclose(writefp);
```

书里就有类似的“基于标准 I/O 的 echo 服务器/客户端”的例子。

使用上的注意

- **千万不要在同一个 fd 上混用 `read/write` 和 `fgets/fputs`**：
    - 标准 I/O 有自己的缓冲，会先从 fd 读一大块放到 buffer 里；
    - 如果你又直接 `read`，会打乱这套管理，出现“读不到 / 丢数据”的怪问题。
- 想要同时读写，比较稳妥的方式：
    - `dup` 一份 fd 出来，一个 `fdopen` 为读，一个为写。

------

### fileno

#### 原型

```c
#include <stdio.h>

int fileno(FILE* stream);
```

#### 作用

- 给你一个 `FILE*`（例如 `stdin` / `stdout` / `stderr` / `fopen` 回来的指针），
- 返回它底层对应的 **文件描述符 int fd**。

#### 典型用途

- 想对 `FILE*` 做 `select` / `poll` / `epoll` 时：
    - 这些系统调用要求的是 `int fd`，就需要 `fileno`。
- 比如想用 `select` 同时监听标准输入和 socket：

```c
int fd_stdin = fileno(stdin);
int fd_sock  = sock;  // 假设已经有 socket 了

fd_set reads;
FD_ZERO(&reads);
FD_SET(fd_stdin, &reads);
FD_SET(fd_sock, &reads);
int fd_max = (fd_stdin > fd_sock) ? fd_stdin : fd_sock;

select(fd_max + 1, &reads, NULL, NULL, NULL);
```

这就是 `fileno` 在网络编程中的常见用法：**让标准 I/O 参与到 I/O 多路复用里**。

------

## 总结

第 15 章整体就是：

> 把“**文件流操作**”这套，更优雅、更高层的 I/O 工具应用到“**网络 socket**”上。

可以这样对照记：

- 文件 I/O（`FILE*`）这几个函数：
    - 打开文件：`fopen`
    - 写：`fputs`, `fputc`
    - 读：`fgetc`, `fgets`
    - 状态：`feof`, `ferror`
- 然后用：
    - `fdopen`：**把 socket fd 套上 FILE 皮，直接用这些函数来操作 socket**；
    - `fileno`：反过来从 `FILE*` 取出 fd，丢给 `select` 之类系统调用。

