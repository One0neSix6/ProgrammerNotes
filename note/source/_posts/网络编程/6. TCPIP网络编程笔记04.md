---
title: TCP/IP网络编程笔记04
date: 2025-12-08 09:31:58
categories: 网络编程
tags: TCP/IP网络编程
---

# 第四章

## 本章整体定位

书名：**《TCP/IP 网络编程》（尹圣雨）**
第 4 章标题：**基于 TCP 的服务器端/客户端（1）**

主要内容：

1. 再次区分 **TCP vs UDP**
2. 讲清楚 **TCP 服务器 / 客户端函数调用顺序**
3. 用一个简单例子实现 **“迭代（一次只服务一个客户端）的 TCP 服务器”**
4. 补充下 **Windows 平台** 的差异（Winsock）

------

## 理解 TCP 和 UDP

### TCP/IP 协议栈四层

书里采用的是经典的 **TCP/IP 四层模型**：

自下而上：

1. **链路层（Link）**
    - 负责物理连接相关的标准：网卡、电缆、Wi-Fi 等。
    - 关心“**两台机器怎么连起来**”。
2. **IP 层（网络层）**
    - 负责在不同网络之间 **转发数据包（路由）**。
    - IP 本身是 **不可靠、无连接** 的，只管“往那边丢包”。
3. **传输层（TCP/UDP 层）**
    - 在 IP 之上实现 **端到端的传输控制**。
    - TCP：有连接、可靠、面向字节流。
    - UDP：无连接、不保证可靠、面向数据报。
4. **应用层**
    - HTTP/FTP/SMTP/你写的服务端程序都在这里。
    - 程序员主要和这一层打交道，底下都通过 **套接字 API** 间接使用。

> 书里的重点：**套接字位于“传输层之上的应用层”**，我们写的代码就是在应用层利用 TCP 或 UDP 来传数据。

------

### TCP 的特点

TCP（Transmission Control Protocol）：

- **面向连接**：通信前必须先 `connect` / 三次握手。
- **面向字节流（stream）**：
    - 发送的是“连续的字节流”，不是一包一包单独的消息。
    - 应用层需要自己划分消息边界（比如定义长度、分隔符）。
- **可靠传输**：
    - 有序性：对方按你发送顺序收到。
    - 不丢不重：通过 **序号 + ACK + 超时重传** 等机制实现。
- 典型应用：
    - Web（HTTP）、SSH、FTP 大多用 TCP。

### UDP 的特点

UDP（User Datagram Protocol）：

- **无连接**：不需要建立连接，直接 `sendto`/`recvfrom`。
- **面向数据报（datagram）**：
    - 一次 `sendto` 对应一次数据报，对方一次 `recvfrom` 收到一整报。
- **不保证可靠**：
    - 包可能丢、乱序、重复，协议本身不管。
- 优点：头部简单、开销小、延迟低。
- 典型应用：
    - 实时音视频、在线游戏、广播/组播。

> **本章后面的代码全部基于 TCP**，只把 UDP 当作对照物来帮你理解 TCP 的特性。

------

## 实现基于 TCP 的服务器端/客户端

这一节是本章的核心：

> **把“TCP 服务器/客户端”抽象成一套固定的函数调用顺序。**

### 2.1 TCP 服务器端的“标准调用顺序”

典型 TCP 服务器流程（Linux 版，伪代码）：

```c
// 1. 创建套接字
int serv_sock = socket(PF_INET, SOCK_STREAM, 0);

// 2. 填写地址结构体（IP + 端口）
struct sockaddr_in serv_addr;
memset(&serv_addr, 0, sizeof(serv_addr));
serv_addr.sin_family = AF_INET;
serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);   // 绑定本机所有 IP
serv_addr.sin_port = htons(12345);              // 监听端口

// 3. 绑定地址到套接字
bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

// 4. 进入“监听”状态（等待连接）
listen(serv_sock, backlog);

// 5. 接受客户端连接（阻塞）
int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_sz);

// 6. 和客户端读写数据（read/write 或 recv/send）

// 7. 关闭套接字
close(clnt_sock);
close(serv_sock);
```

抽象成调用顺序就是：

> ```
> socket → bind → listen → accept → read/write → close
> ```

要点：

- `serv_sock`：**监听套接字**，只负责接受连接，不收发具体业务数据。
- `accept` 成功后产生的新套接字 `clnt_sock`：**连接套接字**，用于和某个客户端交流。
- `accept` 默认是 **阻塞** 的：没有连接来时就卡在那里。

------

### listen：进入「等待连接请求」状态

原型类似：

```c
int listen(int sockfd, int backlog);
```

- `sockfd`：已经 `bind` 好地址的套接字。
- `backlog`：
    - 内核维护的“**连接请求队列**”的最大长度。
    - 当多个客户端同时 `connect`，而服务器还没来得及 `accept`，请求会排队。
    - 如果队列满了，新来的连接请求可能被丢弃或失败。

这里要理解一个重要概念：

> 调用 `listen` 后，服务器并 **不是马上就有客户端连接**，只是告诉内核：“这个套接字以后负责被动接受 TCP 连接。”

------

### accept：受理客户端连接请求

原型类似：

```c
int accept(int sockfd, struct sockaddr* addr, socklen_t *addrlen);
```

- `sockfd`：监听套接字。
- `addr` / `addrlen`：用于返回客户端的地址信息（IP + 端口）。
- 返回值：**新的连接套接字**，之后用它收发数据。

特点：

- 默认 **阻塞**：若没有排队的连接请求，就一直卡住。
- 一旦返回，说明已经“**建立好 TCP 连接（三次握手已完成）**”。

------

### 客户端的标准调用顺序

TCP 客户端流程更短：

```c
// 1. 创建套接字
int sock = socket(PF_INET, SOCK_STREAM, 0);

// 2. 准备服务器地址结构体 serv_addr（IP + 端口）
//    客户端一般不手动 bind，操作系统会自动分配本地端口

// 3. 发起连接请求
connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

// 4. 与服务器收发数据（read/write 或 recv/send）

// 5. 结束后关闭套接字
close(sock);
```

抽象为：

> ```
> socket → connect → read/write → close
> ```

要点：

- 客户端通常 **不显式调用 `bind`**，由系统自动选择本地端口。
- `connect` 失败常见原因：
    - 服务器没启动 / IP 写错 / 端口错。
    - 防火墙 / 中间网络问题。

------

### 服务器端 & 客户端的函数调用关系

书里有一张示意图，展示两端各自调用的函数，大致可以用这样的表记住：

| 服务器端                        | 客户端                                       |
| ------------------------------- | -------------------------------------------- |
| `socket()`                      | `socket()`                                   |
| `bind()`                        | -（通常不写，调用 connect 时系统自动选端口） |
| `listen()`                      | -                                            |
| `accept()`（建立连接）          | `connect()`（发起连接）                      |
| `read()/write()` 或 `recv/send` | `read()/write()` 或 `recv/send`              |
| `close()`                       | `close()`                                    |

------

## 实现迭代服务器端/客户端

### 什么是迭代服务器

- **迭代服务器（iterative server）**：每次只处理 **一个客户端**，直到该客户端结束，再处理下一个。
- 简单循环结构：

```c
serv_sock = socket(...);
bind(...);
listen(serv_sock, ...);

while (1) {
    clnt_sock = accept(serv_sock, ...);  // 等待一个客户端
    // 这里和这个客户端进行数据交互（比如回声 echo）
    // ...
    close(clnt_sock);                     // 当前客户端结束
}
// 通常不会执行到这里
close(serv_sock);
```

特点：

- 实现容易，逻辑清晰，非常适合作为 **入门示例**。
- 缺点明显：
    - 一个客户端长时间占用服务器时，其它客户端只能在 `accept` 阻塞，排队等待。
    - 对于并发连接很多的场景不适用。

书里一般用 **回声服务器（echo server）** 来演示：

- 服务器收到什么就原样发回去。
- 客户端从键盘读入一行，发给服务器，再把回来的数据打印出来。

这一节的目的不是追求高性能，而是：

> **把“多次 accept 多个客户端”的使用方式先搞明白，再为后面多进程/多线程/多路复用做铺垫。**

------

## Windows 实现

本章最后简单提到 **Windows 平台（Winsock）** 的差异：

主要区别：

1. 使用前要初始化：

    ```c
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &wsaData);
    ```

2. 结束时要清理：

    ```c
    WSACleanup();
    ```

3. 关闭套接字用：

    ```c
    closesocket(sock);
    ```

4. 函数名、参数基本和 BSD 套接字兼容（`socket` / `bind` / `listen` / `accept` / `connect` 等都一样）。

大体上可以理解为：

> **Linux / Windows 在 API 名字和调用顺序上高度相似，只是 Windows 需要多一步“初始化网络库”。**

------

## 本章知识点小结

你可以用这一小段来快速复习第 4 章：

1. **TCP vs UDP**：
    - TCP：面向连接、面向字节流、可靠、按序，到应用层需自己划分消息边界。
    - UDP：无连接、面向数据报、不保证可靠，但简单、延迟小。
2. **TCP 服务器函数调用顺序**：
    - `socket → bind → listen → accept → read/write → close`
3. **TCP 客户端函数调用顺序**：
    - `socket → connect → read/write → close`
4. **listen 的作用**：
    - 把套接字变成 **监听套接字**，在内核中建立“连接请求队列”，参数 `backlog` 控制队列长度。
5. **accept 的作用**：
    - 从连接请求队列中取出一个完成三次握手的连接，返回一个新的“连接套接字”，默认阻塞。
6. **迭代服务器的概念**：
    - 一个 `while(1)` 循环中，每次 `accept` 一个客户端，服务完毕后关闭，再处理下一个客户端。简单但不支持高并发。

## 代码

echo_server.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define BUFF_SIZE 1024

void error_handling(char* message);

int main(int argc, char* argv[]) {
    int server_sock, client_sock;
    char message[BUFF_SIZE];
    struct sockaddr_in server_addr;
    if (argc != 2) {
        printf("Usage: %s <port>\n", argv[0]);
        exit(1);
    }
    server_sock = socket(PF_INET, SOCK_STREAM, 0);
    if (server_sock == -1) {
        error_handling("socket() error");
    }
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(atoi(argv[1]));

    if (bind(server_sock, (struct sockaddr*) &server_addr, sizeof(server_addr)) == -1) {
        error_handling("bind() error");
    }

    if (listen(server_sock, 5) == -1) {
        error_handling("listen() error");
    }

    int str_len = 0;
    for (int i = 0; i < 5; i++) {
        client_sock = accept(server_sock, NULL, NULL);
        if (client_sock == -1) {
            error_handling("accept() error");
        } else {
            printf("connect client %d\n", i + 1);
        }
        while (1) {
            str_len = read(client_sock, message, BUFF_SIZE - 1);
            if (str_len > 0) {
                message[str_len] = 0;
                printf("from client, message: %s\n", message);
                write(client_sock, message, str_len);
            } else if (str_len == 0) {
                // 对端正常关闭
                break;
            } else {
                // 出错：str_len < 0
                error_handling("read() error");
                break;
            }
        }
        close(client_sock);
    }

    close(server_sock);
    return 0;
}

void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}

```

echo_client.c

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define BUFF_SIZE 1024

void error_handling(char* message);

int main(int argc, char* argv[]) {
    int sock;
    char message[BUFF_SIZE];
    struct sockaddr_in server_addr;
    if (argc != 3) {
        printf("Usage: %s <IP> <port>\n", argv[0]);
        exit(1);
    }

    sock = socket(PF_INET, SOCK_STREAM, 0);
    if (sock == -1) {
        error_handling("socket() error");
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr(argv[1]);
    server_addr.sin_port = htons(atoi(argv[2]));

    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        error_handling("connect() error");
    }

    int str_len = 0;
    while (1) {
        fputs("Input message, Q to quit\n", stdout);
        fgets(message, BUFF_SIZE, stdin);
        if (!strcmp(message, "q\n") || !strcmp(message, "Q\n")) {
            break;
        }
        write(sock, message, strlen(message));
        str_len = read(sock, message, BUFF_SIZE - 1);
        message[str_len] = 0;
        printf("message from server: %s\n", message);
    }

    close(sock);
    return 0;
}

void error_handling(char* message) {
    fputs(message, stderr);
    fputc('\n', stderr);
    exit(1);
}

```

